[1,["1brw/JvvpFnIvdrxpFCgMZ","ceEBKOJEFK8oQ/aeRUWpDH@bc8eb","ceEBKOJEFK8oQ/aeRUWpDH@fe382","ceEBKOJEFK8oQ/aeRUWpDH@8a258","ceEBKOJEFK8oQ/aeRUWpDH@5db85","ceEBKOJEFK8oQ/aeRUWpDH@2f6f3","ceEBKOJEFK8oQ/aeRUWpDH@5a64d","ceEBKOJEFK8oQ/aeRUWpDH@f8b09","ceEBKOJEFK8oQ/aeRUWpDH@8ba75","ceEBKOJEFK8oQ/aeRUWpDH@c5a39","ceEBKOJEFK8oQ/aeRUWpDH@549da","956S2klmpEBo1ImU/Ontdo@6c48a","ceI5ji7HNHNrDdAezBZxoh@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@48c5b","ceEBKOJEFK8oQ/aeRUWpDH@76c75","ceEBKOJEFK8oQ/aeRUWpDH@73b7f","e1oiWUs61Kyr5BsgFyAoND@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@60f7a","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@801ec","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","e6IlruvvBI4pNCM/eC0Ejz@6c48a","32wWSGS/tNgJ+6wlD/LEf2@6c48a","edCDzXqaNHPL1FosVEgxPT@6c48a","45iDXIizZFS4RzkgP+MbHy@6c48a","d12ywu+1ZBn6w/NGOTndMG@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@3f65d","ceEBKOJEFK8oQ/aeRUWpDH@f729f","ceEBKOJEFK8oQ/aeRUWpDH@bd2ec","bfIIYkI6RBxZ7myVlM5+Mw@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@de1f5","ceEBKOJEFK8oQ/aeRUWpDH@8de70","ceEBKOJEFK8oQ/aeRUWpDH@7812b","c8sBjLoj9AwqEOHVxPwJnY@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@3d06b","ceEBKOJEFK8oQ/aeRUWpDH@5c09d","ceEBKOJEFK8oQ/aeRUWpDH@6f69f","ceEBKOJEFK8oQ/aeRUWpDH@795a8","ceEBKOJEFK8oQ/aeRUWpDH@91378","ceEBKOJEFK8oQ/aeRUWpDH@acaab","ceEBKOJEFK8oQ/aeRUWpDH@f7764","ceEBKOJEFK8oQ/aeRUWpDH@f3289","ceEBKOJEFK8oQ/aeRUWpDH@df271","ceEBKOJEFK8oQ/aeRUWpDH@628f7","ceEBKOJEFK8oQ/aeRUWpDH@a849a","ceEBKOJEFK8oQ/aeRUWpDH@f9cec","ceEBKOJEFK8oQ/aeRUWpDH@ff81c","ceEBKOJEFK8oQ/aeRUWpDH@27427","ceEBKOJEFK8oQ/aeRUWpDH@5cf3a","ceEBKOJEFK8oQ/aeRUWpDH@c44ff","ceEBKOJEFK8oQ/aeRUWpDH@442ec","ceEBKOJEFK8oQ/aeRUWpDH@71e1d","ceEBKOJEFK8oQ/aeRUWpDH@fb9eb","ceEBKOJEFK8oQ/aeRUWpDH@a1415","ceEBKOJEFK8oQ/aeRUWpDH@ee0f4","ceEBKOJEFK8oQ/aeRUWpDH@53ad8","ceEBKOJEFK8oQ/aeRUWpDH@36954","ceEBKOJEFK8oQ/aeRUWpDH@d6c59","ceEBKOJEFK8oQ/aeRUWpDH@9c871","ceEBKOJEFK8oQ/aeRUWpDH@407cc","ceEBKOJEFK8oQ/aeRUWpDH@e3682","ceEBKOJEFK8oQ/aeRUWpDH@33460","ceEBKOJEFK8oQ/aeRUWpDH@371e3","ceEBKOJEFK8oQ/aeRUWpDH@2dbdd","ceEBKOJEFK8oQ/aeRUWpDH@1a7b0","ceEBKOJEFK8oQ/aeRUWpDH@9043e","ceEBKOJEFK8oQ/aeRUWpDH@ccac1","ceEBKOJEFK8oQ/aeRUWpDH@3e324","ceEBKOJEFK8oQ/aeRUWpDH@9b673","ceEBKOJEFK8oQ/aeRUWpDH@31aeb","ceEBKOJEFK8oQ/aeRUWpDH@0982b","ceEBKOJEFK8oQ/aeRUWpDH@52c7a","ceEBKOJEFK8oQ/aeRUWpDH@fc54d","ceEBKOJEFK8oQ/aeRUWpDH@01e18","ceEBKOJEFK8oQ/aeRUWpDH@352ff","ceEBKOJEFK8oQ/aeRUWpDH@1f746","ceEBKOJEFK8oQ/aeRUWpDH@12984","ceEBKOJEFK8oQ/aeRUWpDH@904e1","ceEBKOJEFK8oQ/aeRUWpDH@3b943","ceEBKOJEFK8oQ/aeRUWpDH@dcf87","ceEBKOJEFK8oQ/aeRUWpDH@c95c5","ceEBKOJEFK8oQ/aeRUWpDH@8e8b8","ceEBKOJEFK8oQ/aeRUWpDH@5998d","ceEBKOJEFK8oQ/aeRUWpDH@98c7d","ceEBKOJEFK8oQ/aeRUWpDH@9a914","ceEBKOJEFK8oQ/aeRUWpDH@edb34","ceEBKOJEFK8oQ/aeRUWpDH@d001f","ceEBKOJEFK8oQ/aeRUWpDH@a7293","ceEBKOJEFK8oQ/aeRUWpDH@04c87","ceEBKOJEFK8oQ/aeRUWpDH@e2a05","ceEBKOJEFK8oQ/aeRUWpDH@79ff5","ceEBKOJEFK8oQ/aeRUWpDH@3a703","ceEBKOJEFK8oQ/aeRUWpDH@68166","ceEBKOJEFK8oQ/aeRUWpDH@163e8","ceEBKOJEFK8oQ/aeRUWpDH@10b22","ceEBKOJEFK8oQ/aeRUWpDH@3692f","ceEBKOJEFK8oQ/aeRUWpDH@5c990","ceEBKOJEFK8oQ/aeRUWpDH@20304","ceEBKOJEFK8oQ/aeRUWpDH@4cd98","ceEBKOJEFK8oQ/aeRUWpDH@b5495","ceEBKOJEFK8oQ/aeRUWpDH@5fe06","ceEBKOJEFK8oQ/aeRUWpDH@66021","ceEBKOJEFK8oQ/aeRUWpDH@74c33","ceEBKOJEFK8oQ/aeRUWpDH@4e709","ceEBKOJEFK8oQ/aeRUWpDH@88629","ceEBKOJEFK8oQ/aeRUWpDH@07de2","ceEBKOJEFK8oQ/aeRUWpDH@defa2","ceEBKOJEFK8oQ/aeRUWpDH@d9073","ceEBKOJEFK8oQ/aeRUWpDH@1a13e","ceEBKOJEFK8oQ/aeRUWpDH@c5ef1","ceEBKOJEFK8oQ/aeRUWpDH@46540","ceEBKOJEFK8oQ/aeRUWpDH@95469","ceEBKOJEFK8oQ/aeRUWpDH@c1e93","ceEBKOJEFK8oQ/aeRUWpDH@f7fe5","ceEBKOJEFK8oQ/aeRUWpDH@5a1da","ceEBKOJEFK8oQ/aeRUWpDH@ec301","ceEBKOJEFK8oQ/aeRUWpDH@20d53","ceEBKOJEFK8oQ/aeRUWpDH@8f30c","ceEBKOJEFK8oQ/aeRUWpDH@a551d","ceEBKOJEFK8oQ/aeRUWpDH@77730","ceEBKOJEFK8oQ/aeRUWpDH@101aa","ceEBKOJEFK8oQ/aeRUWpDH@65f2d","ceEBKOJEFK8oQ/aeRUWpDH@2d319","ceEBKOJEFK8oQ/aeRUWpDH@d8f27","ceEBKOJEFK8oQ/aeRUWpDH@d8b50","ceEBKOJEFK8oQ/aeRUWpDH@75988","ceEBKOJEFK8oQ/aeRUWpDH@213a6","ceEBKOJEFK8oQ/aeRUWpDH@1beca","ceEBKOJEFK8oQ/aeRUWpDH@be324","ceEBKOJEFK8oQ/aeRUWpDH@527c9","ceEBKOJEFK8oQ/aeRUWpDH@ced3c","ceEBKOJEFK8oQ/aeRUWpDH@a7ed6","ceEBKOJEFK8oQ/aeRUWpDH@55574","ceEBKOJEFK8oQ/aeRUWpDH@5b906","ceEBKOJEFK8oQ/aeRUWpDH@9259d","ceEBKOJEFK8oQ/aeRUWpDH@17ab5","ceEBKOJEFK8oQ/aeRUWpDH@19427","ceEBKOJEFK8oQ/aeRUWpDH@bedcd","ceEBKOJEFK8oQ/aeRUWpDH@51d01","ceEBKOJEFK8oQ/aeRUWpDH@d3400","ceEBKOJEFK8oQ/aeRUWpDH@f9eae","ceEBKOJEFK8oQ/aeRUWpDH@55357","ceEBKOJEFK8oQ/aeRUWpDH@1708f","ceEBKOJEFK8oQ/aeRUWpDH@e9ac3","ceEBKOJEFK8oQ/aeRUWpDH@578e4","ceEBKOJEFK8oQ/aeRUWpDH@3ccab","ceEBKOJEFK8oQ/aeRUWpDH@c9e18","ceEBKOJEFK8oQ/aeRUWpDH@5b37a","ceEBKOJEFK8oQ/aeRUWpDH@c8a27","ceEBKOJEFK8oQ/aeRUWpDH@7d29f","ceEBKOJEFK8oQ/aeRUWpDH@97e54","ceEBKOJEFK8oQ/aeRUWpDH@bf1bd","ceEBKOJEFK8oQ/aeRUWpDH@d62d4","ceEBKOJEFK8oQ/aeRUWpDH@abbac","ceEBKOJEFK8oQ/aeRUWpDH@c6a24","ceEBKOJEFK8oQ/aeRUWpDH@c6327","ceEBKOJEFK8oQ/aeRUWpDH@1e846","ceEBKOJEFK8oQ/aeRUWpDH@796e7","ceEBKOJEFK8oQ/aeRUWpDH@c1a98","ceEBKOJEFK8oQ/aeRUWpDH@c19ef","ceEBKOJEFK8oQ/aeRUWpDH@37db9","ceEBKOJEFK8oQ/aeRUWpDH@90656","ceEBKOJEFK8oQ/aeRUWpDH@f536d","ceEBKOJEFK8oQ/aeRUWpDH@13520","ceEBKOJEFK8oQ/aeRUWpDH@31d55","ceEBKOJEFK8oQ/aeRUWpDH@f56f5","ceEBKOJEFK8oQ/aeRUWpDH@59b45","ceEBKOJEFK8oQ/aeRUWpDH@5b6fb","ceEBKOJEFK8oQ/aeRUWpDH@7cb6c","ceEBKOJEFK8oQ/aeRUWpDH@b8f50","ceEBKOJEFK8oQ/aeRUWpDH@94312","ceEBKOJEFK8oQ/aeRUWpDH@df8d5","ceEBKOJEFK8oQ/aeRUWpDH@59523","ceEBKOJEFK8oQ/aeRUWpDH@3efbe","ceEBKOJEFK8oQ/aeRUWpDH@443a8","ceEBKOJEFK8oQ/aeRUWpDH@d3737","ceEBKOJEFK8oQ/aeRUWpDH@58994","ceEBKOJEFK8oQ/aeRUWpDH@e7f26","ceEBKOJEFK8oQ/aeRUWpDH@63326","ceEBKOJEFK8oQ/aeRUWpDH@27632","ceEBKOJEFK8oQ/aeRUWpDH@ef95e","ceEBKOJEFK8oQ/aeRUWpDH@12bee","ceEBKOJEFK8oQ/aeRUWpDH@5d6f6","ceEBKOJEFK8oQ/aeRUWpDH@f41a1","ceEBKOJEFK8oQ/aeRUWpDH@d5e5f","ceEBKOJEFK8oQ/aeRUWpDH@6b79f","ceEBKOJEFK8oQ/aeRUWpDH@7b25c","ceEBKOJEFK8oQ/aeRUWpDH@46c84","ceEBKOJEFK8oQ/aeRUWpDH@4e724","ceEBKOJEFK8oQ/aeRUWpDH@0a80a","ceEBKOJEFK8oQ/aeRUWpDH@f527e","ceEBKOJEFK8oQ/aeRUWpDH@47e89","ceEBKOJEFK8oQ/aeRUWpDH@0ece9","ceEBKOJEFK8oQ/aeRUWpDH@3f614","ceEBKOJEFK8oQ/aeRUWpDH@b74c3","ceEBKOJEFK8oQ/aeRUWpDH@fc21a","ceEBKOJEFK8oQ/aeRUWpDH@d930e","ceEBKOJEFK8oQ/aeRUWpDH@1321a","ceEBKOJEFK8oQ/aeRUWpDH@69e1a","ceEBKOJEFK8oQ/aeRUWpDH@43fec","ceEBKOJEFK8oQ/aeRUWpDH@8cb9b","ceEBKOJEFK8oQ/aeRUWpDH@aaa63","182JcwTv9KNorhadCO9GZr@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@890f2","8cacJcMs1EbZuMjsQOHoiF@6c48a","76PVq0WGBP878KY7tUa2TC@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@141be","ceEBKOJEFK8oQ/aeRUWpDH@af103","1dmsHdAs1LooMYrv3Dy5np@6c48a","ceEBKOJEFK8oQ/aeRUWpDH@d3b8c","ceEBKOJEFK8oQ/aeRUWpDH@e685f","72VHo3YpBJ6pX6VF+C1L3q@6c48a","6a5Pl/xdBI9oz2ZqEpGIAg@6c48a","4evktARcdA34d7cvexVyAJ@6c48a"],["node","_mesh","_parent","root","_effectAsset","mainTexture","scene","asset","value","_envmapHDR","_envmapLDR","data","_defaultClip"],[["cc.Node",["_name","_id","_objFlags","__editorExtras__","_parent","_lpos","_prefab","_components","_lrot","_euler","_lscale","_children"],-1,1,5,4,9,5,5,5,2],"cc.ImageAsset",["cc.Node",["_name","_children","_prefab","_parent","_lpos","_components","_lrot","_euler"],2,12,4,1,5,9,5,5],"cc.TextureCube",["cc.PrefabInfo",["fileId","nestedPrefabInstanceRoots","root","instance","asset"],2,2,1,4,6],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh","__prefab"],2,1,3,4,6,4],["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.TargetInfo",["localID"],2],["eca49zjVLNEVrYHA8WhIIV/",["node"],3,1],["cc.PrefabInstance",["fileId","propertyOverrides"],2,9],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["cc.DirectionalLight",["node","_staticSettings"],3,1,4],["cc.StaticLightSettings",[],3],["cc.Camera",["_clearFlags","_visibility","node"],1,1],["cc.MeshRenderer",["_materials","node","__prefab","lightmapSettings","_mesh"],2,1,4,4,6],["cc.ModelLightmapSettings",[],3],["cc.Material",["_props","_defines"],1],["cc.Prefab",[],3],["cc.Animation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.CompPrefabInfo",["fileId"],2]],[[11,0,1,2,2],[7,0,1,2,3],[28,1],[32,0,2],[5,1,5,2,3,4,1],[0,0,4,6,5,8,9,2],[0,0,4,7,6,5,8,9,2],[0,0,4,7,6,5,2],[6,2,0,1,3,4],[6,0,1,3,3],[0,0,4,7,6,5,8,10,9,2],[0,0,4,6,5,8,10,9,2],[0,0,4,7,6,5,10,2],[27,0,1,2,3,4,2],[0,0,4,7,6,8,9,2],[0,0,4,6,5,10,2],[0,0,4,6,5,2],[0,0,4,11,6,5,2],[21,0,1,2,2],[18,0,2],[0,0,4,11,6,5,8,9,2],[2,0,3,1,2,4,6,7,2],[8,0,1,2,4],[9,0,2],[10,0,1,2,3,2],[4,0,1,2],[4,0,2,3,4,2],[12,0,1,2,3,4,1],[13,0,1,2,3,4,2],[14,0,1],[15,0,1,2,2],[16,1],[17,1],[0,0,1,4,11,7,5,10,3],[0,2,3,4,6,3],[0,0,1,4,7,8,9,3],[0,0,4,7,5,10,2],[0,0,4,7,2],[2,0,1,5,2,2],[2,0,3,1,2,4,2],[19,0,1],[20,0,1,2],[22,0,1,2,3],[23,0,1,2,2],[24,0,1,1],[25,1],[26,0,1,2,3],[5,0,1,2,3,4,2],[29,0,1,3],[30,1],[31,0,1,2,3,1]],[[[[1,".bin",2864929873,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":73976,"length":24576,"count":6144,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":73976,"count":1321,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-1,-0.5],"maxPosition",8,[1,0.5,1,0.5]]],-1],0,0,[],[],[]],[[[22,"builtin-standard",[{"hash":2489015834,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":2052537501,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[3],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[23,"scene"],[24,"scene",[-2,-3,-4],[25,"f46876e4-e81b-4931-b493-6d367be385e7",[-1]],[27,[28,0.5208,[2,0.242613,0.362617,0.798746,0.520833125],[2,0.241814,0.361945,0.798799,0],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[29,[4,4283190348]],[30,true,4,5],[31],[32]]],[19,["d2Kbmeb6xRN5Nuy0ez5gzQ"]],[33,"Player","1970fO2qlOaIgpXjeDpJQN",1,[-6,-7],[[40,-5]],[1,0,0.28,0],[1,0.28,0.28,0.28]],[34,0,null,1,[26,"d2Kbmeb6xRN5Nuy0ez5gzQ",-8,[41,"05mZfFHVBPUIKUNGkYtGHI",[[18,["_lpos"],2,[1,0,0,0]],[42,"zhantingFBX",["_name"],2],[18,["_lrot"],2,[3,0,0,0,1]],[18,["_euler"],2,[1,0,0,0]],[43,["_materials","0"],[19,["5cHXgbknxaxaNkglQdbnIz"]],1]]],0]],[35,"Main Light","c0y6F5f+pAvI805TdmxIjx",1,[[44,-9,[45]]],[3,-0.8005972817813567,-0.1453229557254247,-0.33176781330654553,0.4773419623260901],[1,-120.254,-42.248,-4.821]],[36,"Main Camera",3,[[46,14,1822425087,-10]],[1,-5.407142857142856,1.8249999999999997,5.857142857142856],[1,3.5714285714285707,3.5714285714285707,3.5714285714285707]],[37,"Body",3,[[47,"Capsule<ModelComponent>",-11,[2],[2],3]]]],0,[0,-1,4,0,-1,5,0,-2,4,0,-3,3,0,0,3,0,-1,6,0,-2,7,0,3,4,0,0,5,0,0,6,0,0,7,0,6,1,11],[0,0,0,0,0,0],[7,8,-1,1,9,10],[17,9,18,19,20,21]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[11,0]],[[[1,".bin",3564332847,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8640,"length":4224,"count":1056,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8640,"count":360,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.18239232897758484,-0.28274068236351013,-0.03386249020695686],"maxPosition",8,[1,0.41218137741088867,0.23903439939022064,0.012991199269890785]]],-1],0,0,[],[],[]],[[[1,".bin",3144104642,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.1686045229434967,-0.3534669280052185,-0.07500001788139343],"maxPosition",8,[1,0.2481086403131485,0.3581656813621521,0.07500004023313522]]],-1],0,0,[],[],[]],[[[1,".bin",2223902180,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.4249999523162842,-1.0499999523162842,0],"maxPosition",8,[1,1.4249999523162842,1.0499999523162842,0.07999999821186066]]],-1],0,0,[],[],[]],[[[1,".bin",806599281,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3072,"length":720,"count":180,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3072,"count":64,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-4.299999237060547,-8.20000171661377,0],"maxPosition",8,[1,4.299999237060547,8.20000171661377,0.5]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184]],{},{}],11,0,0]]],0,0,[0],[4],[0]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",4070775680,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.5685960054397583,-1.6006817817687988,-0.020000245422124863],"maxPosition",8,[1,2.450000047683716,1.5918534994125366,0.019999999552965164]]],-1],0,0,[],[],[]],[[[1,".bin",1975726165,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":288,"count":72,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.39328905940055847,-0.8170164823532104,0],"maxPosition",8,[1,0.45410358905792236,1.3829823732376099,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",2818373282,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.9210665225982666,-1.4273241758346558,0],"maxPosition",8,[1,2.9210665225982666,1.4273241758346558,0.05296679958701134]]],-1],0,0,[],[],[]],[[[1,".bin",4160202902,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2295912504196167,-0.800000011920929,7.629394893626795e-9],"maxPosition",8,[1,-0.019685424864292145,1.4382561445236206,0.01000001560896635]]],-1],0,0,[],[],[]],[[[1,".bin",2135746852,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3168,"length":576,"count":144,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3168,"count":66,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.04000048711895943,-5.699999809265137,-1.2250006198883057],"maxPosition",8,[1,0.04000048711895943,5.6999993324279785,1.2250006198883057]]],-1],0,0,[],[],[]],[[[1,".bin",3444864012,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.2400009632110596,-1.6006817817687988,-0.020000968128442764],"maxPosition",8,[1,1.5425034761428833,1.5918534994125366,0.019999999552965164]]],-1],0,0,[],[],[]],[[[1,".bin",1784424391,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.651111602783203,-8.959161758422852,6.000000212225132e-7],"maxPosition",8,[1,-2.0131239891052246,-8.894160270690918,2.5000009536743164]]],-1],0,0,[],[],[]],[[[1,".bin",3010044835,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.6950136423110962,-0.03000006079673767,0],"maxPosition",8,[1,1.9760932922363281,0.029999999329447746,3.201364040374756]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[22,0]],[[[1,".bin",1147675195,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.17417651414871216,0.15222248435020447,-0.0750000849366188],"maxPosition",8,[1,0.17868702113628387,0.5738582611083984,0.07499997317790985]]],-1],0,0,[],[],[]],[[[1,".bin",3607360817,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":29616,"length":13104,"count":3276,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":29616,"count":1234,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.003386665368452668,-0.0027093354146927595,-2.960655332007178e-11],"maxPosition",8,[1,0.0033866730518639088,0.0027093314565718174,0.0009999999310821295]]],-1],0,0,[],[],[]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",3282657061,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35712,"length":35712,"count":8928,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35712,"count":1488,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.410003423690796,-1.410003423690796,-0.009999999776482582],"maxPosition",8,[1,1.410003423690796,1.410003423690796,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",3852851274,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.4249999523162842,-0.904226541519165,0],"maxPosition",8,[1,1.4249999523162842,0.904226541519165,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",3782791295,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.149459958076477,-0.0024999999441206455,0],"maxPosition",8,[1,0.5394560694694519,0.0024999999441206455,3.200000047683716]]],-1],0,0,[],[],[]],[[[1,".bin",1870998651,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":96,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":96,"count":4,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.387393057346344,-1.600000023841858,0],"maxPosition",8,[1,-0.0036220704205334187,1.600000023841858,0]]],-1],0,0,[],[],[]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",449130019,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.5897305011749268,-1.600000023841858,0],"maxPosition",8,[1,2.5,1.600000023841858,0.0010000000474974513]]],-1],0,0,[],[],[]],[[[1,".bin",3357442206,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5961874723434448,0.9378681778907776,0],"maxPosition",8,[1,0.5961874723434448,1.0223798751831055,0.019999999552965164]]],-1],0,0,[],[],[]],[[[1,".bin",540223327,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6912,"length":864,"count":216,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6912,"count":144,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9603751301765442,-0.586906373500824,-0.11143945157527924],"maxPosition",8,[1,1.5085393190383911,1.5026133060455322,0.004999999888241291]]],-1],0,0,[],[],[]],[[[1,".bin",676901475,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22656,"length":10032,"count":2508,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22656,"count":944,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.0030037497635930777,-0.00379747012630105,-0.005000011529773474],"maxPosition",8,[1,0.0030037423130124807,0.003797454759478569,-0.004000011365860701]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-14-6284",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0,"roughness":0.19405344128608704},"albedoScale",8,[1,0.4473039209842682,0.4473039209842682,0.4473039209842682]]],11]]],0,0,[0],[4],[0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[23,0]],[[[1,".bin",803407053,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.4722578525543213,-1.600000023841858,0],"maxPosition",8,[1,2.622253894805908,1.600000023841858,0.0010000065667554736]]],-1],0,0,[],[],[]],[[[1,".bin",1823081329,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26640,"length":11808,"count":2952,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":26640,"count":1110,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.0030849457252770662,-0.0038311767857521772,-1.338685239049564e-11],"maxPosition",8,[1,0.0030671844724565744,0.003831153968349099,0.0009999999310821295]]],-1],0,0,[],[],[]],[[[1,".bin",533162366,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.4249999523162842,-1.0499999523162842,0],"maxPosition",8,[1,1.4249999523162842,1.0499999523162842,0.07999999821186066]]],-1],0,0,[],[],[]],[[[1,".bin",382011314,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.5685967206954956,-1.6006817817687988,-0.020000236108899117],"maxPosition",8,[1,1.732473611831665,1.5918537378311157,0.019999999552965164]]],-1],0,0,[],[],[]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[24,0]],[[[1,".bin",1648720844,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.27044129371643066,-1.5200005769729614,0],"maxPosition",8,[1,1.5498751401901245,1.5200005769729614,0.03999999910593033]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[25,0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[26,0]],[[[8,"Mat3d66-4399328-1-4545",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.7710670232772827,"roughness":0.061035413295030594},"albedoScale",8,[1,0.8245515823364258,0.8245515823364258,0.8245515823364258]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",2146044981,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5760,"length":864,"count":216,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5760,"count":120,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.3416454792022705,-1.3670055866241455,-15.750001907348633],"maxPosition",8,[1,1.860561490058899,1.590400218963623,0.2500000298023224]]],-1],0,0,[],[],[]],[[[8,"zhanqiang08",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[27,0]],[[[1,".bin",3006273233,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3072,"length":720,"count":180,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3072,"count":64,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-3.482734441757202,-2.199866771697998,0],"maxPosition",8,[1,3.4575634002685547,2.199866771697998,0.5000090599060059]]],-1],0,0,[],[],[]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",2458617318,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3790566623210907,-1.1191270351409912,-0.004999977070838213],"maxPosition",8,[1,-0.19247381389141083,1.1191288232803345,0.005000030621886253]]],-1],0,0,[],[],[]],[[[1,".bin",846442605,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6449999809265137,-0.3700000047683716,0],"maxPosition",8,[1,0.6449999809265137,0.3700000047683716,0.004999999888241291]]],-1],0,0,[],[],[]],[[[1,".bin",2516951554,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.800000011920929,-1.1830039024353027,0],"maxPosition",8,[1,0.800000011920929,1.1830039024353027,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",3989874055,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2058336,"length":428124,"count":107031,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2058336,"count":42882,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3994160294532776,-4.300000190734863,-0.004354492295533419],"maxPosition",8,[1,21.21681785583496,12.100004196166992,3.2295830249786377]]],-1],0,0,[],[],[]],[[[1,".bin",3745669439,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1536,"length":240,"count":60,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1536,"count":32,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-6.40811824798584,-2.09999942779541,0],"maxPosition",8,[1,6.40811824798584,2.0999996662139893,0.48109155893325806]]],-1],0,0,[],[],[]],[[[1,".bin",1909179687,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.8055479526519775,-6.100001811981201,0],"maxPosition",8,[1,3.0955615043640137,6.100001811981201,0.5]]],-1],0,0,[],[],[]],[[[8,"muwen",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[28,0]],[[[8,"zhanqiang11",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[29,0]],[[[1,".bin",2573888651,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.20579496026039124,-0.2668214440345764,-0.07500003278255463],"maxPosition",8,[1,0.26534220576286316,0.43325942754745483,0.07500001043081284]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[12,0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[30,0]],[[[1,".bin",2674452795,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":13824,"length":2304,"count":576,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":13824,"count":288,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2544569969177246,-1.0647598505020142,-0.06571969389915466],"maxPosition",8,[1,1.2544572353363037,1.0647597312927246,0.06571975350379944]]],-1],0,0,[],[],[]],[[[1,".bin",3852851274,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.4249999523162842,-0.904226541519165,0],"maxPosition",8,[1,1.4249999523162842,0.904226541519165,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",1823081329,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26640,"length":11808,"count":2952,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":26640,"count":1110,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.0030849457252770662,-0.0038311767857521772,-1.338685239049564e-11],"maxPosition",8,[1,0.0030671844724565744,0.003831153968349099,0.0009999999310821295]]],-1],0,0,[],[],[]],[[[8,"wenzi",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[31,0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[32,0]],[[[1,".bin",1184705392,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.6489765644073486,-1.0142070055007935,0],"maxPosition",8,[1,0.6539375185966492,1.125,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",4133362689,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8064,"length":1008,"count":252,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8064,"count":168,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.5001020431518555,-8.874160766601562,0.9661349058151245],"maxPosition",8,[1,-3.9314470291137695,-8.864160537719727,2.108534812927246]]],-1],0,0,[],[],[]],[[[1,".bin",2384898623,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9499995112419128,-1.600000023841858,0],"maxPosition",8,[1,0.800000011920929,1.600000023841858,0.0010000000474974513]]],-1],0,0,[],[],[]],[[[1,".bin",2648478441,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.1769297122955322,-0.009999999776482582,-0.003000000026077032],"maxPosition",8,[1,2.9051601886749268,0.009999999776482582,0.003000006778165698]]],-1],0,0,[],[],[]],[[[1,".bin",4041428768,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.600000023841858,-0.05000000074505806,-0.15000000596046448],"maxPosition",8,[1,1.600000023841858,0.05000000074505806,0.15000000596046448]]],-1],0,0,[],[],[]],[[[1,".bin",1163211176,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7680,"length":1680,"count":420,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":7680,"count":160,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-3.4389023780822754,-1.1830039024353027,0],"maxPosition",8,[1,1.5056133270263672,1.1830039024353027,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",1254991797,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-3.3185606002807617,-0.997499942779541,-7.629394893626795e-9],"maxPosition",8,[1,3.338573932647705,0.9975002408027649,0.06999999284744263]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-26-2331",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.5052787661552429,"roughness":0.061035413295030594},"albedoScale",8,[1,0.8539584875106812,0.8539584875106812,0.8539584875106812]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",1220900526,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.7000000476837158,-1.3975703716278076,0],"maxPosition",8,[1,1.4803476333618164,1.254546880722046,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",2989552122,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.6600000262260437,-0.38499999046325684,-0.003000000026077032],"maxPosition",8,[1,0.6600000262260437,0.38499999046325684,0.003000000026077032]]],-1],0,0,[],[],[]],[[[1,".bin",2329988371,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":153696,"length":31104,"count":7776,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":153696,"count":3202,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.4265556037425995,-0.5149931311607361,-0.0009975165594369173],"maxPosition",8,[1,0.42648622393608093,0.35003983974456787,0.08061721920967102]]],-1],0,0,[],[],[]],[[[1,".bin",1208438969,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-6.199994087219238,-8.449999809265137,0],"maxPosition",8,[1,15.216236114501953,7.9500041007995605,0.0010000000474974513]]],-1],0,0,[],[],[]],[[[8,"zhanqiang111",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[33,0]],[[[1,".bin",3231540652,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.6499999761581421,-0.375,0],"maxPosition",8,[1,0.6499999761581421,0.375,0.004999999888241291]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-31-1098",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184]]],11]]],0,0,[0],[4],[0]],[[[8,"Mat3d66-4399328-29-3232",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0,0,0],"emissiveScale",8,[2,0.699999988079071,0.699999988079071,0.699999988079071,1]]],11]]],0,0,[0],[4],[0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[34,0]],[[[49],[38,"zhantingFBX",[[-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,[5,"Camera001",-32,[0,"10alQKPmtbraz+QGaAX1nq",-31,0],[1,-5.283092498779297,1.5308927297592163,6.355120658874512],[3,-2.8822720146311223e-30,-0.7064571202332162,-4.3258021155444936e-17,0.7077558458054523],[1,-3.501910830583443e-15,-89.8947662411481,-3.508348618549311e-15]],[5,"Camera001.Target",-34,[0,"2dX2ZV/8dd6YqWAi4c75k7",-33,0],[1,5.058854579925537,1.5308927297592163,6.336125373840332],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera002",-36,[0,"9fibi1DnZRA72y64O8WGyo",-35,0],[1,-2.2053816318511963,0.8967606425285339,8.839704513549805],[3,0.05656028830953927,-0.00005897512444508142,0.000003340998271328946,0.9983991838423719],[1,6.48479231343561,-0.006768887189434055,-1.081643100133578e-11]],[5,"Camera002.Target",-38,[0,"a8fMB6/gVfN5QN51JRMET8",-37,0],[1,-2.2033703327178955,2.83184814453125,-8.184515953063965],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera003",-40,[0,"88kMW8dohViKV+WcowvGk1",-39,0],[1,-0.24588964879512787,0.7000070810317993,7.87335729598999],[3,0.05511555308995949,0.17610370668124065,-0.009876142937890794,0.9827778091213627],[1,6.419730159898746,20.318000444483108,-1.058987762194154e-7]],[5,"Camera003.Target",-42,[0,"c053lm+WVbg6j4oaW+EK3Z",-41,0],[1,-7.876875877380371,3.172755718231201,-12.735976219177246],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera004",-44,[0,"1dJZZpDrlcyrFonL9mI/9/",-43,0],[1,1.409609317779541,1.5742017030715942,-1.5684726238250732],[3,-0.00922928402928181,0.7069343519525625,0.009226355019705488,0.7071587634462065],[1,-1.4954746352420234,89.98181473152484,-1.345028029312655e-8]],[5,"Camera004.Target",-46,[0,"16RYcD3FJUX7riiqbJCTlf",-45,0],[1,-45.8650016784668,0.34000879526138306,-1.583478569984436],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera005",-48,[0,"fcrRVWONRSGIHRuQ+yiS4b",-47,0],[1,6.3547539710998535,0.8967606425285339,6.086847305297852],[3,0.056560288309491356,-0.00005898943989143357,0.000003341809313214876,0.9983991838415261],[1,6.484792313435608,-0.0067705302493611,-4.194870385312124e-12]],[5,"Camera005.Target",-50,[0,"8eYS1Lt/pbOKReD0M11VKb",-49,0],[1,6.3567657470703125,2.83184814453125,-10.937371253967285],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera006",-52,[0,"14WGWFkpVWB5W0AqbA4O1l",-51,0],[1,9.433060646057129,0.8967606425285339,-0.36499032378196716],[3,0.01974980696519182,0.7080107845341648,-0.019815958806900784,0.7056472219776092],[1,3.206376263760535,90.19159093953792,4.688111957255104e-9]],[5,"Camera006.Target",-54,[0,"509mdVznxYa4Df3cutnbRH",-53,0],[1,-25.109350204467773,2.83184814453125,-0.24948330223560333],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera007",-56,[0,"d8+38ZZUVe7YRc3IqnCNfX",-55,0],[1,7.443639755249023,0.9692385792732239,6.745169639587402],[3,0.05511555308995949,0.17610370668124065,-0.009876142937890794,0.9827778091213627],[1,6.419730159898746,20.318000444483108,-1.058987762194154e-7]],[5,"Camera007.Target",-58,[0,"164fuyCdtU44N4yzVY2J73",-57,0],[1,-0.1873469203710556,3.4419870376586914,-13.864164352416992],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera009",-60,[0,"3d1dmFdmRV/oAE/PhXda3X",-59,0],[1,12.195428848266602,0.9159209132194519,6.9751081466674805],[3,0.05656030316298252,-0.00005898943984171644,0.00000334181021989304,0.9983991830000613],[1,6.484794018249411,-0.00677053024954954,-8.685508284419513e-13]],[5,"Camera009.Target",-62,[0,"56NHGejblTZY5kmsLxH8yB",-61,0],[1,12.197440147399902,2.8510091304779053,-10.049111366271973],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera010",-64,[0,"21DtXWU25WuKmE+hxwV1le",-63,0],[1,14.524889945983887,2.3694355487823486,5.370998859405518],[3,-0.07228591880250448,0.2447734421666547,0.01830300462497286,0.966708698613219],[1,-8.5526998820993,28.417660924641734,7.061715268994987e-8]],[5,"Camera010.Target",-66,[0,"b3Qyj8L/ZQPotCk52Wo+ZZ",-65,0],[1,3.694507122039795,-1.0531599521636963,-14.644624710083008],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera011",-68,[0,"2e5Ky3ZC5c5r6cO0hNYf4e",-67,0],[1,14.702781677246094,1.7924787998199463,-5.995904922485352],[3,-0.016681123540155957,0.9454817184509801,0.049052409872558274,0.32152748137307713],[1,-5.939783842032591,142.43701362737167,5.169956012506514e-8]],[5,"Camera011.Target",-70,[0,"997/8/84xWJrFFwn81JH8f",-69,0],[1,-5.351933002471924,-1.6301169395446777,20.080503463745117],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera012",-72,[0,"1ew+CT1QhViZ9HGuGXMqMa",-71,0],[1,-4.141296863555908,1.344361424446106,6.539408206939697],[3,0.052052638854214066,-0.00005426139191150657,0.0000028282827005677903,0.998644341012362],[1,5.967489914506936,-0.00622633827866296,-1.4116699089840613e-11]],[5,"Camera012.Target",-74,[0,"d9ZnymnOhcpoNlO81Z5N7c",-73,0],[1,-4.139285087585449,3.279448986053467,-11.972755432128906],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera013",-76,[0,"47WAA4HTRZRbA6D+zjRb0I",-75,0],[1,14.838518142700195,1.423376441001892,7.274670124053955],[3,0.012505179194344613,0.7063131289043652,-0.012481043038649027,0.707679028935654],[1,2.0247016110081826,89.88930591728531,-1.987337767287197e-8]],[5,"Camera013.Target",-78,[0,"f4LfNIwWBb5IA0dbKHj9tL",-77,0],[1,-39.898433685302734,3.358464002609253,7.168920040130615],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera014",-80,[0,"7c8twKD2xd061w5wQg7hkz",-79,0],[1,14.929668426513672,1.6640077829360962,6.089157581329346],[3,-0.014867055198015155,0.9022562484499126,0.031208721854036017,0.4298123410083365],[1,-3.962101500088321,129.0560725823061,4.027919948153369e-8]],[5,"Camera014.Target",-82,[0,"b2emFOU7JdPYwoYsgDMu4L",-81,0],[1,-16.440778732299805,-1.1340625286102295,31.543315887451172],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"Camera015",-84,[0,"93tW8DaUZQHr0IPPolTuC+",-83,0],[1,2.058551788330078,1.6640077829360962,9.020916938781738],[3,-0.03413587508753466,-0.44005883676882934,-0.016743649153737144,0.8971636486320039],[1,-4.357953127492239,-52.255908346674794,1.3398684738729847e-8]],[5,"Camera015.Target",-86,[0,"2535vVYX5fBJXnK1+x3L31",-85,0],[1,31.092145919799805,-1.1340625286102295,-13.45450496673584],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"PhysCamera001",-88,[0,"2fjDVj7zhVraD7H2kuYIdt",-87,0],[1,1.2192893028259277,70.8896255493164,1.5533145666122437],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"PhysCamera001.Target",-90,[0,"b0TY7HjYpUcpV7xci1I002",-89,0],[1,1.2192893028259277,-2.139859437942505,1.5533145666122437],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],-91,-92,-93,-94,-95,[5,"VR-020",-97,[0,"d4FSQxlg5RObUkjOi9memB",-96,0],[1,10.75978946685791,3.201354503631592,1.2531992197036743],[3,0.707106900395829,0,0,0.7071066619772459],[1,90.00001931869265,0,0]],[5,"VR-021",-99,[0,"2bBa16xdBT3rJAWt0Owm5q",-98,0],[1,13.063616752624512,3.201354503631592,1.2531992197036743],[3,0.707106900395829,0,0,0.7071066619772459],[1,90.00001931869265,0,0]],-100,[5,"VR-019",-102,[0,"7b6fBTC+tWlZdqLnVnbmFW",-101,0],[1,8.451164245605469,3.201354503631592,1.2531992197036743],[3,0.707106900395829,0,0,0.7071066619772459],[1,90.00001931869265,0,0]],-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,[11,"CR_001",-115,[0,"537svkFUZWjquUKhVuEip4",-114,0],[1,-1.975584864616394,3.158507823944092,6.609862327575684],[3,-0.5,0.5,0.5,0.5],[1,0.5150570273399353,1.922929048538208,1],[1,-90,90,0]],[11,"CR_002",-117,[0,"63pCqTrfdRyZTVl9cXQBPp",-116,0],[1,-2.076413869857788,2.7172489166259766,2.39330792427063],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,0.4960229992866516,1.5834579467773438,1],[1,-90.00000000000003,0,0]],[11,"CR_004",-119,[0,"48Z/sHv5BTHLsBG05QveDw",-118,0],[1,-2.067530870437622,2.7172489166259766,-2.6505703926086426],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,0.4960229992866516,1.5834579467773438,1],[1,-90.00000000000003,0,0]],[11,"CR_006",-121,[0,"b0bSl7yPJVAJMDcbv8JZN6",-120,0],[1,5.121709823608398,2.8004722595214844,1.9110013246536255],[3,-0.5,-0.5,-0.5,0.5],[1,0.9549880027770996,1.675042986869812,1.8127000331878662],[1,-90,-90,0]],[11,"CR_008",-123,[0,"7eHT7ehupSM5DuaSRPGi6r",-122,0],[1,11.68462085723877,3.1610288619995117,3.2203569412231445],[3,-0.5,-0.5,-0.5,0.5],[1,0.364888995885849,2.032526969909668,1.8127000331878662],[1,-90,-90,0]],[11,"CR_009",-125,[0,"5emuKypUZcCbgJgrs5oFWp",-124,0],[1,8.558440208435059,3.125913143157959,7.281043529510498],[3,-0.5,-0.5,-0.5,0.5],[1,0.2705270051956177,4.168920040130615,1.8127000331878662],[1,-90,-90,0]],-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136,-137,-138,-139,-140,-141,-142,-143,-144,[5,"VR-003",-146,[0,"174zlJMapYeaJ59y/+6/JZ",-145,0],[1,-5.829951763153076,1.6551138162612915,-0.718064546585083],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],-147,-148,-149,-150,-151,-152,-153,-154,[11,"VR-007",-156,[0,"9aq6VG51dTUK2DY3aUL9iM",-155,0],[1,2.163212299346924,1.7383739948272705,0.2832890748977661],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,1,1,0.6663960218429565],[1,0.0000025044781562438674,90.00000000000001,0]],[5,"VR-008",-158,[0,"87qZppshdSPphxjUWIjExY",-157,0],[1,2.311443328857422,1.6013544797897339,4.25851583480835],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],-159,-160,-161,-162,-163,-164,-165,-166,-167,-168,[5,"VR-025",-170,[0,"a3a7mk3OBQHJ8kMpErpBJQ",-169,0],[1,11.72814655303955,1.4902031421661377,9.197669982910156],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[5,"CR_010",-172,[0,"a8+747HHBY6ZVQHE0wy8Jt",-171,0],[1,-0.6542894840240479,2.8989341259002686,8.181166648864746],[3,2.2496020536224808e-17,0.8665237447411849,0.4991358530497622,8.362253382361134e-17],[1,-59.88568989442151,180,7.016709384901079e-15]],[5,"CR_010.Target",-174,[0,"9e1hXZvgFcEJAPAxlAx7xs",-173,0],[1,-0.6542894840240479,0.042173050343990326,9.838127136230469],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_011",-176,[0,"00hCQ/GD5XjZiNFxLTo9Ki",-175,0],[1,0.6455751061439514,2.8989341259002686,8.181166648864746],[3,2.2496020536224808e-17,0.8665237447411849,0.4991358530497622,8.362253382361134e-17],[1,-59.88568989442151,180,7.016709384901079e-15]],[5,"CR_011.Target",-178,[0,"eauiWU8zdT/qMdzmEjt+op",-177,0],[1,0.6455751061439514,0.042173050343990326,9.838127136230469],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_023",-180,[0,"84hS26yktanbw/bTeF5oBZ",-179,0],[1,14.52582836151123,3.197162628173828,8.48420524597168],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_023.Target",-182,[0,"25Cy1jlPlRyYTCtQkcWYbi",-181,0],[1,14.52582836151123,0.042173050343990326,8.48420524597168],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_024",-184,[0,"92Jmdkb1dUtoJhJ6yEgeOO",-183,0],[1,14.52582836151123,3.197162628173828,6.913397789001465],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_024.Target",-186,[0,"f6vHFQwsdZSo8dwl8Z/HuT",-185,0],[1,14.52582836151123,0.042173050343990326,6.913397789001465],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_025",-188,[0,"67kMFqGUdX6qmKn0UJmH3V",-187,0],[1,14.541029930114746,3.197162628173828,6.06806755065918],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_025.Target",-190,[0,"06JqQVjB1clbDPeK/N++D8",-189,0],[1,14.541029930114746,0.042173050343990326,6.06806755065918],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_047",-192,[0,"414SqIpGNRH51vNkUT7Olo",-191,0],[1,-4.781635284423828,2.8989341259002686,2.2878482341766357],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_047.Target",-194,[0,"c78AKsXuFX5qxqyQJzGSWy",-193,0],[1,-4.781635284423828,0.042173050343990326,2.2878482341766357],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_048",-196,[0,"c8r0RHXyNfartWWjyjTlmJ",-195,0],[1,-4.781635284423828,2.8989341259002686,0.9982065558433533],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_048.Target",-198,[0,"71jI2mJQhRXJLxZBhi+UaT",-197,0],[1,-4.781635284423828,0.042173050343990326,0.9982065558433533],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_049",-200,[0,"1cRO8dUPRU761zdCVuuWKk",-199,0],[1,-4.781635284423828,2.8989341259002686,-0.2914350628852844],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_049.Target",-202,[0,"afX5WvdTpQM4widjtT/yOg",-201,0],[1,-4.781635284423828,0.042173050343990326,-0.2914350628852844],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_050",-204,[0,"63ZbkZgZdVC6guWv6bGDXx",-203,0],[1,-4.781635284423828,2.8989341259002686,-1.7453545331954956],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_050.Target",-206,[0,"1fgsms0z9QhLYrpMX/d6v4",-205,0],[1,-4.781635284423828,0.042173050343990326,-1.7453545331954956],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_051",-208,[0,"fcy+wpFbZeFZncGqibB8aJ",-207,0],[1,-4.781635284423828,2.8989341259002686,-3.0697097778320312],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_051.Target",-210,[0,"fdHMYcD1BeBqiiUpYTMFJq",-209,0],[1,-4.781635284423828,0.042173050343990326,-3.0697097778320312],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_052",-212,[0,"5b0YXdxCRVvJa8J+RBuK4d",-211,0],[1,-4.781635284423828,2.8989341259002686,-4.394064903259277],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_052.Target",-214,[0,"25RY2zmjlW07asu+he9k4q",-213,0],[1,-4.781635284423828,0.042173050343990326,-4.394064903259277],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_059",-216,[0,"076+FlfilZM7/xbBdRTJMz",-215,0],[1,0.7877188920974731,2.8989341259002686,0.4172060489654541],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_059.Target",-218,[0,"casUxonllX1JT789RdWQNz",-217,0],[1,0.7877188920974731,0.042173050343990326,0.4172060489654541],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_060",-220,[0,"23g9gtNcJQcICs+GNOmSwN",-219,0],[1,0.7877188920974731,2.8989341259002686,2.8617265224456787],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_060.Target",-222,[0,"8a3z1FHS9dCpYqikfol1w7",-221,0],[1,0.7877188920974731,0.042173050343990326,2.8617265224456787],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[11,"CR_061",-224,[0,"d0DRW29MBYIKcOxHuQnqrY",-223,0],[1,-4.849536418914795,3.1615841388702393,-0.14045853912830353],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,0.08705200254917145,3.9227700233459473,1],[1,-90.00000000000003,0,0]],[11,"CR_062",-226,[0,"25HMTHz29QeL56aNsKuQuD",-225,0],[1,0.8142003417015076,3.1615841388702393,-0.14045853912830353],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,0.08705200254917145,3.9227700233459473,1],[1,-90.00000000000003,0,0]],[11,"CR_063",-228,[0,"34JnGPUk1RA6+YahkUXTUY",-227,0],[1,5.121709823608398,2.8004722595214844,-3.7163925170898438],[3,-0.5,-0.5,-0.5,0.5],[1,0.6241869926452637,1.675042986869812,1.8127000331878662],[1,-90,-90,0]],[5,"CR_074",-230,[0,"b0szvRBJJSsbKvIx1GWjSi",-229,0],[1,1.1668047904968262,2.0777554512023926,9.065642356872559],[3,4.084871792554509e-8,-0.8651835863310205,7.047815086602168e-8,0.5014552442076828],[1,0.000009334667720040406,-119.80735004936163,-2.197889630358573e-13]],[5,"CR_075",-232,[0,"cdeesc6dxWUJIC/Bd7my3y",-231,0],[1,-1.2384259700775146,2.0777554512023926,9.065642356872559],[3,4.0184269317988656e-8,0.8698600738586995,-7.08590962859945e-8,0.493298542372194],[1,0.000009334667383437216,120.8847665035743,2.939515790336082e-13]],[11,"CR_076",-234,[0,"f16eU0RTpeDZohDPduV00F",-233,0],[1,-0.03884991630911827,0.9310329556465149,9.065642356872559],[3,0.6117771777481511,0.6117771777481511,0.3545823047119713,-0.35458251332822505],[1,1,1.049025058746338,1],[1,-89.99999023105853,-89.99999023105853,29.807349041770877]],[5,"CR_077",-236,[0,"2aKoDhTJNQvq4ZByGLU21l",-235,0],[1,14.52582836151123,3.197162628173828,7.720022678375244],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[5,"CR_077.Target",-238,[0,"e2ss76UrFRb5CYoofx7bAi",-237,0],[1,14.52582836151123,0.042173050343990326,7.720022678375244],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],-239,-240,-241,-242,-243,-244,-245,-246,-247,-248],1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,4,4,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1],[[50,-2,[3,"d7ZKcRjGBbVbARS2/NrHkT"],[249],250]],[0,"d2Kbmeb6xRN5Nuy0ez5gzQ",-1,0]],[39,"Group-4399328-3-443",1,[[-249,-250,-251,-252,-253,-254,-255,-256,-257,[15,"VR-004",-258,[0,"78vymv/9FXVJ4lfGEZiVNU",1,0],[1,1.2000000476837158,0.20000000298023224,-0.12231787294149399],[1,1,1,0.7707300186157227]],[16,"VR-005",-259,[0,"c4TyRduEhb5aRrYbx4/RPo",1,0],[1,2.4000000953674316,0.550000011920929,-0.12999512255191803]],[5,"VR-006",-260,[0,"c7h3kycstbP7iN6T4s4hzA",1,0],[1,-3.5,1.600000023841858,-0.05473535135388374],[3,0.7071068407911908,0,0,0.7071067215818992],[1,90.00000965934633,0,0]],-261,-262],1,1,1,1,1,1,1,1,1,4,4,4,1,1],[0,"ebqPpAZARahoYx3edFdaM6",1,0],[1,-2.1504452228546143,1.6000005006790161,-6.1923370361328125]],[17,"Group-4399328-4-427",2,[-263,-264,-265,-266,-267,-268],[0,"f2NRE+6chQfY9jUQ2PX2zU",1,0],[1,2.4000000953674316,0.8088359236717224,0.11244042962789536]],[17,"Group-4399328-5-367",2,[-269,-270,-271,-272,-273,-274],[0,"f0DmSYRI5er7wfAoInrtWW",1,0],[1,2.4000000953674316,0.8088359236717224,0.11931493878364563]],[21,"Group-4399328-8-904",1,[[-275,-276,-277,-278,[16,"VR-013",-279,[0,"fb48j5iLlXV7a/faoUVAOb",1,0],[1,-1.4249999523162842,-2.2737368624290214e-16,-0.07499463111162186]],[15,"VR-015",-280,[0,"e0NuIY9S9V85FpPxZRugIG",1,0],[1,0.5000002384185791,0.20000000298023224,-0.06565380841493607],[1,1,1.05656898021698,0.6851739883422852]]],1,1,1,1,4,4],[0,"01q4FMHC5Yw5ROIOPuwgqC",1,0],[1,8.076157569885254,1.6000007390975952,-4.397332191467285],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[21,"Group-4399328-9-437",1,[[-281,-282,-283,-284,[16,"VR-014",-285,[0,"bb/j9S1btc2JMJmkvMo1Hb",1,0],[1,1.4253437519073486,0,-0.07499511539936066]],[15,"VR-016",-286,[0,"04CfX1wYlfEL+TaGkPE/A6",1,0],[1,-0.5000312328338623,0.20000000298023224,-0.06565380841493607],[1,1,1.05656898021698,0.6851739883422852]]],1,1,1,1,4,4],[0,"18XbPruZ5XpLNqE2cVXpXe",1,0],[1,8.076157569885254,1.6000005006790161,-0.5476757884025574],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[20,"Group-4399328-17-223",1,[-287,-288,-289,-290,-291],[0,"52yxXFcdxS5Ke2jP36/V/W",1,0],[1,-0.050999999046325684,1.600033164024353,8.947667121887207],[3,-1.01657506197672e-15,0.9999999999999989,-2.185569414336894e-8,-4.371138828673788e-8],[1,0.0000025044780654876664,-179.99999499104388,-7.016708042882758e-15]],[17,"Group-4399328-18-369",7,[-292,-293,-294,-295],[0,"14QQrO89BagK7JAT1If8BR",1,0],[1,-0.02505468763411045,-1.323691487312317,0.004416015464812517]],[20,"Group001",1,[-296,-297,-298],[0,"baFy40nBxR2IA55uZB3UB/",1,0],[1,15.051288604736328,1.6154687404632568,7.320798873901367],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-2-803",1,[[4,-299,[3,"f3zur3iS5X+qM4UweOeULW"],[0],[2],1]],[0,"cd6YMfUN9eKLqguJGbV1fm",1,0],[1,-0.04994921758770943,0.0003535156138241291,1.327671766281128],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-7-647",1,[[4,-300,[3,"bbpMBkLVBfVa1MgG/BWbt5"],[2],[2],3]],[0,"cc6sLLchpWwKRg1twDSoM5",1,0],[1,-4.765929698944092,2.8500003814697266,9.031661033630371],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[6,"Obj3d66-4399328-8-29",1,[[4,-301,[3,"466xBj2WJW3aLt1jCQYX7v"],[4],[2],5]],[0,"61gXSY5HdT1rd7jAqLVsCS",1,0],[1,-2.0131237506866455,1.2500007152557373,8.919160842895508],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[6,"Obj3d66-4399328-10-610",1,[[4,-302,[3,"1fpyAhdx5RB6m2bptXM64v"],[6],[2],7]],[0,"5cUCXmoOBW447IKwsXZtOk",1,0],[1,-3.832118034362793,1.2500007152557373,9.02916145324707],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[6,"Obj3d66-4399328-11-826",1,[[4,-303,[3,"2fG8igqOtadYS51PAWqNmo"],[8],[2],9]],[0,"2ccWm5cU5TX4XSNZqLDxLg",1,0],[1,-3.0258190631866455,1.5500006675720215,8.87916088104248],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[6,"Obj3d66-4399328-12-919",1,[[4,-304,[3,"77o7X06tFS/6HkmUEj197V"],[10],[2],11]],[0,"1dQrR6rlhb64m1OfooOULH",1,0],[1,-3.0258190631866455,1.5500006675720215,8.87916088104248],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[6,"Obj3d66-4399328-14-402",1,[[4,-305,[3,"daebLqA99WxrkMewNwBFET"],[12],[2],13]],[0,"f1UiIlvftQfrXjh98tAsXH",1,0],[1,-4.765929698944092,2.8500003814697266,9.094161033630371],[3,3.621976833446857e-15,0.9999999999999865,-2.185569414336867e-8,1.6292068494294434e-7],[1,0.000002504478065487667,179.99998133066472,7.016690247495659e-15]],[7,"Obj3d66-4399328-35-356",2,[[4,-306,[3,"fcm7h6GAhRhJDhd/dz6i+a"],[14],[2],15]],[0,"af6w0lbpVWmbmpc949PO+s",1,0],[1,1.2000000476837158,0.20000000298023224,-0.12999512255191803]],[7,"Obj3d66-4399328-37-568",2,[[4,-307,[3,"63e1MuQEBcjZtHlubdpPfw"],[16],[2],17]],[0,"eaVuKlmnlenZbi1y/qv6z5",1,0],[1,1.2000000476837158,0.20000000298023224,-0.05999511852860451]],[7,"Obj3d66-4399328-38-996",2,[[4,-308,[3,"a5mU5iSW5WDKUVWihD1bva"],[18],[2],19]],[0,"3fNNLWapRbC60bSGKxdpMC",1,0],[1,2.4000000953674316,0.550000011920929,-0.12999512255191803]],[7,"Obj3d66-4399328-39-37",2,[[4,-309,[3,"b0RGuHQldTjazaOosMSWH2"],[20],[2],21]],[0,"1aV0Px/zNVTa8raL5L5j3X",1,0],[1,1.2000000476837158,0,-0.12999512255191803]],[7,"Obj3d66-4399328-42-984",2,[[4,-310,[3,"52AXepLUhcQoPjp2w8N3Hv"],[22],[2],23]],[0,"13Frat+Bpf1bwc5rXtUzlV",1,0],[1,2.4000000953674316,0.023792969062924385,0.11000487953424454]],[7,"Obj3d66-4399328-43-678",2,[[4,-311,[3,"26gsOp+xlRhIu48jyJVMiV"],[24],[2],25]],[0,"5dfIuC06pY+LaXDp0HWOz4",1,0],[1,2.4000000953674316,0.023792969062924385,0.11000487953424454]],[7,"Obj3d66-4399328-45-236",2,[[4,-312,[3,"9fLmBCFIJfCaD6ws9QAUEZ"],[26],[2],27]],[0,"4a6RoWLZ9Zr6DTZQghs/Mw",1,0],[1,2.4000000953674316,0,-0.12999512255191803]],[7,"Obj3d66-4399328-46-257",2,[[4,-313,[3,"68apcc/xBYq7woCC7sXvaH"],[28],[2],29]],[0,"627czd1NNUA5tMgizOADOl",1,0],[1,2.4000000953674316,0.550000011920929,0.08000488579273224]],[7,"Obj3d66-4399328-48-710",2,[[13,[null],-314,[3,"3dPM4lRype/rrInjX0LCIj"],[2],30]],[0,"1cMdobQrRRZL0Kc0S0X7nK",1,0],[1,-3.5,0,-0.12999512255191803]],[7,"Obj3d66-4399328-49-553",3,[[4,-315,[3,"e2KSwbu6RVU72zog+TWkIp"],[31],[2],32]],[0,"b1S1lOzj5R6IN5jKotwIsp",1,0],[1,-0.7343456745147705,0.14740820229053497,-0.004361328203231096]],[12,"Obj3d66-4399328-50-743",3,[[4,-316,[3,"4eQrkUz2lZhpdU8j4Njdu6"],[33],[2],34]],[0,"45580gS8Nc9pbr27hJrnpJ",1,0],[1,-0.7337909936904907,-0.09788867086172104,-0.004103515762835741],[1,8.800209045410156,8.800209045410156,8.800209045410156]],[7,"Obj3d66-4399328-51-728",3,[[4,-317,[3,"1d4Druj49W1Klf9W9ebWFN"],[35],[2],36]],[0,"e0HU4PFxpa7Y1yAnV4cIkm",1,0],[1,-0.7343456745147705,-0.10133398324251175,-0.005638672038912773]],[12,"Obj3d66-4399328-52-648",3,[[4,-318,[3,"98AV47aj1WIbBov0EgFi0J"],[37],[2],38]],[0,"ebqDsgEzVUnIQf2KZMpJrR",1,0],[1,-0.7334238290786743,0.15190820395946503,0.018076172098517418],[1,11.487808227539062,11.487810134887695,3.3858320713043213]],[12,"Obj3d66-4399328-56-779",3,[[4,-319,[3,"02uGWVqMJcOpmMQOghbzpo"],[39],[2],40]],[0,"0cv13GBk5ZCIGRzSD5mRdG",1,0],[1,0.0975332036614418,0.15254101157188416,-0.0005488281021825969],[1,10.588274955749512,10.588274955749512,4.604878902435303]],[7,"Obj3d66-4399328-57-649",3,[[4,-320,[3,"baQFRlOHpfqKP8BurLfLyH"],[41],[2],42]],[0,"00HN/bULVSjrVMHcPjNqKt",1,0],[1,0.09622851759195328,0.14740820229053497,-0.0046582031063735485]],[7,"Obj3d66-4399328-62-121",4,[[4,-321,[3,"92ygFs2jpXNZmT31WE8Oe9"],[43],[2],44]],[0,"54DWrhE2FXQJAZBuNWNW7o",1,0],[1,-0.7343456745147705,0.14740820229053497,-0.004361328203231096]],[12,"Obj3d66-4399328-63-795",4,[[4,-322,[3,"52mKV+08lZsrUlC7V5sCbs"],[45],[2],46]],[0,"5asej4iLRdzYf+JCcslF8T",1,0],[1,-0.7337909936904907,-0.09788867086172104,-0.004103515762835741],[1,8.800209045410156,8.800209045410156,8.800209045410156]],[7,"Obj3d66-4399328-64-107",4,[[4,-323,[3,"d7hpAVekJSg6lKXzNETtRQ"],[47],[2],48]],[0,"ffAdnXn69XBo24YQj2TxCg",1,0],[1,-0.7343456745147705,-0.10133398324251175,-0.005638672038912773]],[12,"Obj3d66-4399328-65-74",4,[[4,-324,[3,"44eWiXCc9TeYcllupmBKV5"],[49],[2],50]],[0,"e3ygQCxdxTHbUN7hu5mFqU",1,0],[1,-0.7334238290786743,0.15190820395946503,0.018076172098517418],[1,11.487808227539062,11.487810134887695,3.3858320713043213]],[12,"Obj3d66-4399328-69-494",4,[[4,-325,[3,"0aGnnMQrtXf4Ova0dh5NQy"],[51],[2],52]],[0,"01mY1WAk9TdK2DrhZQOgsL",1,0],[1,0.0975332036614418,0.15254101157188416,-0.0005488281021825969],[1,10.588274955749512,10.588274955749512,4.604878902435303]],[7,"Obj3d66-4399328-70-280",4,[[4,-326,[3,"32UTY17/Bdw5jhSoV9yhq4"],[53],[2],54]],[0,"70Oe3DzJ5cxKnW/dP0A5Pv",1,0],[1,0.09622851759195328,0.14740820229053497,-0.0046582031063735485]],[7,"Obj3d66-4399328-75-316",1,[[4,-327,[3,"b33MnMgIVeZ5RsRGro8fsC"],[55],[2],56]],[0,"78+sdbUspQjJjnQ7jFPdxn",1,0],[1,6.1406025886535645,1.3670034408569336,9.18766975402832]],[7,"Obj3d66-4399328-104-751",5,[[4,-328,[3,"e01Yufh8FXy4LIjUWiO/YA"],[57],[2],58]],[0,"bdOBw1TChUsbAKIPww/tsD",1,0],[1,-1.4249999523162842,-2.2737368624290214e-16,-0.07499463111162186]],[7,"Obj3d66-4399328-108-275",5,[[4,-329,[3,"3biS+bb+FfrpIFhixINl0V"],[59],[2],60]],[0,"22RtuQ5ClV9Zb04++vc0bI",1,0],[1,0.5000002384185791,0.20000000298023224,-0.004995116963982582]],[7,"Obj3d66-4399328-109-483",5,[[4,-330,[3,"e9AJEsMMFSAqb9JWqCTeq7"],[61],[2],62]],[0,"5ae7qc98Je6bKfiGdY/Vw6",1,0],[1,0.5000002384185791,0.20000000298023224,-0.07499511539936066]],[7,"Obj3d66-4399328-114-700",5,[[4,-331,[3,"3cIZMVwPxcGrQhvHWKdoBM"],[63],[2],64]],[0,"e6eyDs5V1U3q+aBEqfYQxS",1,0],[1,0.5000002384185791,0.20000000298023224,-0.004995116963982582]],[7,"Obj3d66-4399328-122-564",6,[[4,-332,[3,"30lT7URfNf56aLde5AITHi"],[65],[2],66]],[0,"8dU/i4QDBdUYibCZWvHVyu",1,0],[1,-0.4996562600135803,0.20000000298023224,-0.004995116963982582]],[7,"Obj3d66-4399328-123-769",6,[[4,-333,[3,"0dS12QFYtagYFXSVqZ66rd"],[67],[2],68]],[0,"7fNEjgnjJZkYeo/L/8TW5L",1,0],[1,-0.4996562600135803,0.20000000298023224,-0.07499511539936066]],[7,"Obj3d66-4399328-124-730",6,[[4,-334,[3,"795bQqgdFRNYjWIPKiQcVv"],[69],[2],70]],[0,"17GbqRN4NcAoTqP007gVhn",1,0],[1,1.4253437519073486,0,-0.07499511539936066]],[7,"Obj3d66-4399328-126-754",6,[[4,-335,[3,"13FwkT06Nb9Y6YeW6Wq+Nt"],[71],[2],72]],[0,"ceX6LHSkdarrRUY6fHOP3b",1,0],[1,1.4253437519073486,0,-0.07499511539936066]],[7,"Obj3d66-4399328-214-688",7,[[4,-336,[3,"caA+oit0RZGqTxBG+Mex3c"],[73],[2],74]],[0,"13e36oWLRUnK1ZJbtP2fa2",1,0],[1,-0.00995312537997961,0.4499119818210602,-0.07999511808156967]],[7,"Obj3d66-4399328-215-31",7,[[4,-337,[3,"03XJK+771dt4hjOnXESx1V"],[75],[2],76]],[0,"59wH1dtuFSYbU7DdllGp62",1,0],[1,-0.009953129105269909,0.4499117434024811,-0.1499951183795929]],[7,"Obj3d66-4399328-217-500",7,[[4,-338,[3,"ddH72FRhtYnbEqKZ/Bbx4q"],[77],[2],78]],[0,"d9DDu27fNd170Toq0DbB1S",1,0],[1,0,-1.5500333309173584,0.000004882812390860636]],[7,"Obj3d66-4399328-218-32",7,[[4,-339,[3,"4f14YJQcBVpbuot9djvpH4"],[79],[2],80]],[0,"55oNZestNQwr3ivy7L5AJn",1,0],[1,0,-0.00003320312680443749,-0.1499951183795929]],[10,"Obj3d66-4399328-221-754",8,[[4,-340,[3,"93ozH/kEVbpa+wLajoV/cQ"],[81],[2],82]],[0,"d0j7hKE/pUFIKQHNkkTItm",1,0],[1,-0.9485312700271606,0.019925536587834358,-0.12353515625],[3,0.9999999999999991,1.1612292533407645e-22,7.257685988823399e-24,4.371138828673789e-8],[1,-0.9117850065231323,-0.9117850065231323,-0.9117850065231323],[1,179.99999499104388,-8.316689707269851e-22,1.330670708906415e-20]],[10,"Obj3d66-4399328-224-287",8,[[4,-341,[3,"aadx5++Aha6aaTr+J4NGrL"],[83],[2],84]],[0,"c5Pjii7vlRnqyIshg2Trq9",1,0],[1,-0.9485312700271606,0.019925536587834358,-0.07353515923023224],[3,0.9999999999999991,1.1612292533407645e-22,7.257685988823399e-24,4.371138828673789e-8],[1,-0.9117850065231323,-0.9117850065231323,-0.9117850065231323],[1,179.99999499104388,-8.316689707269851e-22,1.330670708906415e-20]],[10,"Obj3d66-4399328-225-921",8,[[4,-342,[3,"287A1CvNlUN7fJoqNqzsNi"],[85],[2],86]],[0,"a9kxZyzRtfAIo6Su3GZPp0",1,0],[1,-0.9485312700271606,0.019925536587834358,-0.07353515923023224],[3,0.9999999999999991,1.1612292533407645e-22,7.257685988823399e-24,4.371138828673789e-8],[1,-0.9117850065231323,-0.9117850065231323,-0.9117850065231323],[1,179.99999499104388,-8.316689707269851e-22,1.330670708906415e-20]],[10,"Obj3d66-4399328-226-334",8,[[4,-343,[3,"54rYqETflZ84id6t3MQCca"],[87],[2],88]],[0,"3a4OiziQ5dT5U2UaxstWua",1,0],[1,-0.9485312700271606,0.019925536587834358,-0.12353515625],[3,0.9999999999999991,1.1612292533407645e-22,7.257685988823399e-24,4.371138828673789e-8],[1,-0.9117850065231323,-0.9117850065231323,-0.9117850065231323],[1,179.99999499104388,-8.316689707269851e-22,1.330670708906415e-20]],[6,"Obj3d66-4399328-228-611",1,[[4,-344,[3,"6dUsfHvUlSPqGJo/n/2Lw8"],[89],[2],90]],[0,"cb8opEhu9f17BqRBr80/ya",1,0],[1,1.6500234603881836,0,1.5898594856262207],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[7,"Obj3d66-4399328-230-360",1,[[4,-345,[3,"b9eNrO3m9UfIxXl28gFtAu"],[91],[2],92]],[0,"93mHC7rD1ZSrLtuFKFaLcY",1,0],[1,2.3001797199249268,1.600000262260437,5.102672100067139]],[6,"Obj3d66-4399328-244-353",1,[[4,-346,[3,"6a4pHCF61YfrVjadnEFdwz"],[93],[2],94]],[0,"67wRvFklJfY4GV+SL37NFz",1,0],[1,2.020587921142578,1.6006826162338257,-3.8723320960998535],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-245-133",1,[[4,-347,[3,"d9sm2/pIFeGbRAQbpOQSRu"],[95],[2],96]],[0,"1a80MZEGtTF6pXvtDCpIPo",1,0],[1,8.126656532287598,1.6006826162338257,2.927671432495117],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[7,"Obj3d66-4399328-247-71",1,[[4,-348,[3,"c9ZPD4MApRi6H9SA9UtFbL"],[97],[2],98]],[0,"aag5yeAAhe257ONk0x8hAQ",1,0],[1,5.501150608062744,1.6006826162338257,5.482088565826416]],[7,"Obj3d66-4399328-250-678",1,[[4,-349,[3,"1eCbkvD5ddNY0IK3vd4Q7Z"],[99],[2],100]],[0,"aaZ8m7dvZQdbSm3UvVHM+W",1,0],[1,11.92631721496582,1.6006826162338257,5.477670669555664]],[6,"Obj3d66-4399328-251-435",1,[[4,-350,[3,"ed8k49pHVfnKM9+Aovq2yB"],[101],[2],102]],[0,"8dMqbKkyJSmKLoCV/t7XYm",1,0],[1,9.110610008239746,0,5.580170631408691],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-252-43",1,[[4,-351,[3,"bf43+zAe1bt4D1IJnIRhtI"],[103],[2],104]],[0,"36xP615AZTYrpQEK0qKvjx",1,0],[1,3.499514579772949,0,5.580172538757324],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-253-394",1,[[4,-352,[3,"e8Xx1wuSNYzptPB5DilyLN"],[105],[2],106]],[0,"68O/OxGb5Zd7FzA+CIu2b6",1,0],[1,3.180586814880371,0,9.195169448852539],[3,-3.090862019268387e-8,0.7071067811865469,0.7071067811865469,3.090862019268387e-8],[1,-90.00000000000001,179.99999499104368,0]],[7,"Obj3d66-4399328-254-476",1,[[4,-353,[3,"6bUUcL9Q9cApvytVGPFVmV"],[107],[2],108]],[0,"85CwlQoUpfOqHtmCcxoJgv",1,0],[1,9.231085777282715,1.613625168800354,5.657670497894287]],[6,"Obj3d66-4399328-255-724",1,[[4,-354,[3,"82kexH6WBS/IkTC+UQUXZo"],[109],[2],110]],[0,"e4+RSEANlUsrNA41B08zvI",1,0],[1,8.465826034545898,1.613625168800354,5.657670497894287],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Obj3d66-4399328-256-690",1,[[4,-355,[3,"11MKWrCGxSSJV0CQM57+CJ"],[111],[2],112]],[0,"b0QSqIDxBe+rSw8BbORD2N",1,0],[1,8.387569427490234,0.6606073975563049,5.657670497894287],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Obj3d66-4399328-257-933",1,[[4,-356,[3,"f7tBLgENhbfKTnrk17bY7V"],[113],[2],114]],[0,"6c949NWJFYvKAkSXlWSq36",1,0],[1,3.410104513168335,1.0816274881362915,5.657670497894287],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Obj3d66-4399328-258-881",1,[[4,-357,[3,"8dgvKIkBNcaq57UoBiTf+e"],[115],[2],116]],[0,"38kSBDyJdQqrdMVeWkJGTu",1,0],[1,2.833418130874634,1.991889238357544,5.657670497894287],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Obj3d66-4399328-259-522",1,[[4,-358,[3,"afVuSH3dxUSo8JmGHiD4Wh"],[117],[2],118]],[0,"ddjyC8fsxYBo+kNKZBocdJ",1,0],[1,3.059375762939453,1.3812851905822754,9.12267017364502],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Obj3d66-4399328-260-19",1,[[4,-359,[3,"5bvQUz8mVfX4DEPEavvrlK"],[119],[2],120]],[0,"e41iBXx3xSpLVeIOZGse2B",1,0],[1,4.282488822937012,2.156128406524658,9.12267017364502],[3,5.76011639363064e-8,5.760116038359266e-8,0.7071067811865451,0.7071067811865451],[1,0,0.000009334668189869458,90]],[6,"Box001",1,[[4,-360,[3,"6f3y1E9KVWQ55d7HJt8mSA"],[121],[2],122]],[0,"2bAEu9GDBXEK9JTCinW2CW",1,0],[1,-6.050527572631836,0.0013544921530410647,5.477672100067139],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[12,"Obj3d66-4399328-131-52",1,[[4,-361,[3,"801rXH/ptdsJumh//vCusr"],[123],[2],124]],[0,"5dm8EdPDZTmJ+L9tJ3825w",1,0],[1,11.608101844787598,1.7469360828399658,1.287667989730835],[1,1,0.8390420079231262,1]],[12,"Obj3d66-4399328-132-361",1,[[4,-362,[3,"c1nXbHLUNe64Wok6RCYnsM"],[125],[2],126]],[0,"38euXyEtFQXJmOl3K3raVf",1,0],[1,11.608101844787598,1.7469360828399658,1.287667989730835],[1,1,0.8390420079231262,1]],[7,"Obj3d66-4399328-134-609",1,[[13,[null],-363,[3,"d3TL3o80JUWoLPGMTFTFdx"],[2],127]],[0,"f8LnjjNcBeZppfv5EqMmk1",1,0],[1,10.760492324829102,1.6013545989990234,1.1779391765594482]],[7,"Obj3d66-4399328-135-508",1,[[13,[null],-364,[3,"e25g6owQZVOqq7HyW7o1IG"],[2],128]],[0,"56Qeg1ZWdR1aACfIn1VwAc",1,0],[1,13.069820404052734,1.6013545989990234,1.1779391765594482]],[7,"Obj3d66-4399328-138-364",1,[[13,[null],-365,[3,"0cE7R5V5pR1pAoIxqrzHHT"],[2],129]],[0,"ddGB/eXShUuZmyMZF6PJ/L",1,0],[1,8.451164245605469,1.6013545989990234,1.1779391765594482]],[6,"Obj3d66-4399328-160-409",1,[[4,-366,[3,"31ajnFeuBa9LTj48Edi8WY"],[130],[2],131]],[0,"8aStHCHkNYJpAqoYsesL0N",1,0],[1,14.982051849365234,1.6013542413711548,3.5526719093322754],[3,-2.6692540190908936e-8,0.707106781186547,2.6692538414552064e-8,0.707106781186547],[1,-0.000004325711157704357,90,-1.4393547659025915e-13]],[6,"Obj3d66-4399328-162-121",1,[[4,-367,[3,"ceIHp95axZzZKu2YmmsOL0"],[132],[2],133]],[0,"d8wMYjvntd4ZMVVtIHK5C/",1,0],[1,14.946420669555664,1.6013543605804443,3.5594482421875],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-166-833",1,[[4,-368,[3,"d4AdOVfbJZuL1cw9yr0QHJ"],[134],[2],135]],[0,"c18NyjRJJaw7al+8auIAL6",1,0],[1,14.821405410766602,1.1651629209518433,3.6811513900756836],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-174-444",1,[[4,-369,[3,"05Zjg253Fd/prUk7kME9Bd"],[136],[2],137]],[0,"12DdycHtFTA6WjnwKPCevl",1,0],[1,14.946420669555664,1.6013543605804443,3.8707528114318848],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-175-664",1,[[4,-370,[3,"98Wg5XZy5VLalwQKSYtE1U"],[138],[2],139]],[0,"8aYWcdGFldMbL5kTCn9gNy",1,0],[1,14.946420669555664,1.6013543605804443,3.2481513023376465],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-176-722",1,[[4,-371,[3,"00ePUeO5Zds7Wxj7oYAYDG"],[140],[2],141]],[0,"abflzr2SZUeYVW70We54JN",1,0],[1,14.946420669555664,1.6013543605804443,4.182049751281738],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-177-853",1,[[4,-372,[3,"a1ukwEdJ1ZyKmcsJ7lF+S+"],[142],[2],143]],[0,"63rHuMkmBT6pgUUsDSB89n",1,0],[1,14.946420669555664,1.6013543605804443,4.493346691131592],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-178-555",1,[[4,-373,[3,"cd0VvQJeJUF55Zpv8zY7Qg"],[144],[2],145]],[0,"acesbCxQ9UEK5Ad5LgRady",1,0],[1,14.946420669555664,1.6013543605804443,4.804643630981445],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-179-109",1,[[4,-374,[3,"abX6XPeapaNIL4uus3ZdCC"],[146],[2],147]],[0,"e5t7GGb49VZpaTzTPHSSU0",1,0],[1,14.946420669555664,1.6013543605804443,5.115940570831299],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-180-811",1,[[4,-375,[3,"a2Jvr5X5pXjpyW9VisXYtc"],[148],[2],149]],[0,"03PlK1Vwhav5wnZn0GAscv",1,0],[1,14.867124557495117,1.6230164766311646,3.955233335494995],[3,1.5454310096341944e-8,-0.7071067811865474,1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,-90.00000000000001,0]],[6,"Obj3d66-4399328-199-746",9,[[4,-376,[3,"77CCEIcZ1R240DztzfxgZe"],[150],[2],151]],[0,"a1Ejea1ilR/I+ALhuvhN+B",1,0],[1,-0.07499804347753525,0.010609375312924385,0.4595312476158142],[3,-0.5000000074505778,0.5000000670552235,0.5000000074505778,-0.4999999180436093],[1,0,269.99998975471533,-90]],[6,"Obj3d66-4399328-200-439",9,[[4,-377,[3,"96NAVYHyxVz4zt5VRoM6a6"],[152],[2],153]],[0,"6cYF/LDxpdcbaijkGUC6SV",1,0],[1,-0.004998046904802322,0.010609375312924385,0.4595312476158142],[3,-0.5000000074505778,0.5000000670552235,0.5000000074505778,-0.4999999180436093],[1,0,269.99998975471533,-90]],[6,"Text001",9,[[4,-378,[3,"15DCQbRsBcYYE3INsI12he"],[154],[2],155]],[0,"6fpWObFBFcw4AebqaC8DJf",1,0],[1,0.07561913877725601,1.2499033212661743,-1.0433332920074463],[3,-0.5000000074505778,0.5000000670552235,0.5000000074505778,-0.4999999180436093],[1,0,269.99998975471533,-90]],[6,"Box008",1,[[4,-379,[3,"7aTF3lzkhSJYwjiHFvfhm4"],[156],[2],157]],[0,"0fmDdqbadTmbJd7wK4eKVM",1,0],[1,6.025060653686523,0,-6.592331886291504],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Box009",1,[[4,-380,[3,"f48a8rGyFdIYZ8EEzguRmX"],[158],[2],159]],[0,"acnY5pn/9ZxbVW+y2h7eZV",1,0],[1,6.025060653686523,0,9.467669486999512],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"gulingfengguang",1,[[4,-381,[3,"1a8f7nMIJXQIIqgyETzk21"],[160],[2],161]],[0,"f2HR5rUXpaOL2XzTp+rzUz",1,0],[1,6.025060653686523,0,-6.532331943511963],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Box011",1,[[4,-382,[3,"d3jfZETkVR5rFvMDMvyKle"],[162],[2],163]],[0,"66/ukpBs9VTrdvLDc6y/el",1,0],[1,6.140600681304932,1.9548894166946411,9.31266975402832],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-244-354",1,[[4,-383,[3,"b9RdrH7epQvbLN4rNNmka4"],[164],[2],165]],[0,"22piJmUtVcyp+PWXn9SUy/",1,0],[1,1.9523192644119263,1.6006826162338257,6.7654805183410645],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[14,"dameifuzhou",1,[[4,-384,[3,"5cHXgbknxaxaNkglQdbnIz"],[166],[2],167]],[0,"47lF2t7w1Tvp0kfcnjPUWS",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[14,"dameiguahua",1,[[4,-385,[3,"4cXSQcwSdYZ66R4v3Gqy2O"],[168],[2],169]],[0,"84IqZgWVlc5Zib7qe/1VVW",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[14,"fuzhouqiang",1,[[4,-386,[3,"63B3e9SPRVD6uHIhptstb+"],[170],[2],171]],[0,"8dgv1C875XE68GvD0xsjjL",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-5-4",1,[[4,-387,[3,"daNu56tuZbd5wPdhVsiKFD"],[172],[2],173]],[0,"55frAsEpJYmq+hSt5Malv5",1,0],[1,-5.650111198425293,1.398924708366394,7.339160442352295],[3,-2.669253906590249e-8,0.7071067513842247,2.6692537289545694e-8,0.7071068109888681],[1,-0.000004325710975389267,89.99999517032704,3.837961012198732e-14]],[6,"Obj3d66-4399328-3-414",1,[[4,-388,[3,"d6JaiA6LlQsr1fh3By03St"],[174],[2],175]],[0,"4fjrNuAQ1c457f2BkCcfpO",1,0],[1,-5.552611351013184,1.3989248275756836,5.63916015625],[3,-2.669253906590249e-8,0.7071067513842247,2.6692537289545694e-8,0.7071068109888681],[1,-0.000004325710975389267,89.99999517032704,3.837961012198732e-14]],[14,"Obj3d66_4399328_6_960",1,[[4,-389,[3,"2dtO6MjV9X+JUDGpT05mC8"],[176],[2],177]],[0,"246laqn+BTBqv/BWAqLB74",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[14,"Obj3d66_4399328_13_454",1,[[4,-390,[3,"30pAUsxgtTY6Y8FT1JH0oc"],[178],[2],179]],[0,"a8ssKnP15WJqzi5HS7Dnhl",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Obj3d66-4399328-16-38",1,[[4,-391,[3,"72bOz/kiZaw6MKlsAD+1m2"],[180],[2],181]],[0,"39l2bgYmJcj4wBHKEWUUV9",1,0],[1,-5.606189250946045,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.70620197057724,0.70620197057724,1.1271270513534546],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-20-495",1,[[4,-392,[3,"4aOZnMjvtTBLkngeuirC8d"],[182],[2],183]],[0,"748eQXA4hVOaLWViYSW6xO",1,0],[1,-5.829951763153076,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[10,"Obj3d66-4399328-21-924",1,[[4,-393,[3,"54pMKx4iVXMp4jQRczmQo+"],[184],[2],185]],[0,"128RRUvIxaz7aZRSNk8jzE",1,0],[1,-5.447230339050293,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.70620197057724,0.70620197057724,1.1271270513534546],[1,0.0000025044781562438674,90.00000000000001,0]],[10,"Obj3d66-4399328-22-460",1,[[4,-394,[3,"42Px1Qsc9QGqQVhFpkiIWO"],[186],[2],187]],[0,"b4ipMV0kJW27wrFg4+hFKG",1,0],[1,-5.554962635040283,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.70620197057724,0.70620197057724,1.1271270513534546],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-23-23",1,[[4,-395,[3,"3b9XHu3jdeZKhS7o7wx+c7"],[188],[2],189]],[0,"05l0TrBv5YQZS79hJJJeUM",1,0],[1,-5.674951553344727,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[10,"Obj3d66-4399328-25-644",1,[[4,-396,[3,"9eSt8QT51Wy7fb31SweXZ0"],[190],[2],191]],[0,"e38db7p0lRzrql/3IUpp0D",1,0],[1,-5.495898246765137,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.70620197057724,0.70620197057724,1.1271270513534546],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-27-810",1,[[4,-397,[3,"5b2oFg9xJcHLmOi+UMmaA4"],[192],[2],193]],[0,"e2myu6lqte74S/SjxPiwkX",1,0],[1,-5.759951591491699,1.6000005006790161,3.5064921379089355],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Box004",1,[[4,-398,[3,"daC3FcFHVbVKTWOeJXya+h"],[194],[2],195]],[0,"43BRgKT1Je4ZjFvdqFAo87",1,0],[1,-5.719952583312988,1.6249979734420776,-0.6223282814025879],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Obj3d66-4399328-78-726",1,[[4,-399,[3,"87TnLdovRZpLO/uakopvn4"],[196],[2],197]],[0,"e2YHqo6C5W9rCj5IdWuw3V",1,0],[1,2.150621175765991,1.6013544797897339,1.249929666519165],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-81-550",1,[[4,-400,[3,"d7qBlAyGlc+7XLyWiEyNsG"],[198],[2],199]],[0,"c3rgWnk/VZ5r2By24XhL8u",1,0],[1,2.230620861053467,1.7383739948272705,0.2832890748977661],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[10,"Obj3d66-4399328-85-907",1,[[4,-401,[3,"70c/sX5s5S6qQhXTLqDBz6"],[200],[2],201]],[0,"43ysbImYdb4blM6V0Kq6sz",1,0],[1,2.4906210899353027,1.721498966217041,4.277671813964844],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,1.135450005531311,1.135450005531311,1.135450005531311],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-87-19",1,[[4,-402,[3,"c0VGctF3pTSqJGUn8DIE6/"],[202],[2],203]],[0,"43Ppoap8JdN75scW10o6n2",1,0],[1,2.4906210899353027,1.721498966217041,4.277671813964844],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-88-861",1,[[4,-403,[3,"644uGY1iFSI5YGrXc+0o0O"],[204],[2],205]],[0,"32rmDUiuVQMJXEpqCuRTse",1,0],[1,2.4906210899353027,1.721498966217041,4.277671813964844],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-91-865",1,[[4,-404,[3,"80DfYXWm1c4I91r6sQs0Cz"],[206],[2],207]],[0,"09d/8j7TpQvY8ks4FfZin2",1,0],[1,2.272050380706787,2.9092178344726562,3.8737733364105225],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[6,"Obj3d66-4399328-93-389",1,[[4,-405,[3,"3abHCGBrxSq7DlGqDEEdty"],[208],[2],209]],[0,"63U+jsECVSTqawIsSymvmQ",1,0],[1,2.150621175765991,3.0502450466156006,1.5328359603881836],[3,1.5454310096341944e-8,0.7071067811865474,-1.5454310096341944e-8,0.7071067811865474],[1,0.0000025044781562438674,90.00000000000001,0]],[7,"Obj3d66-4399328-96-45",1,[[4,-406,[3,"0fNfDZsGNRHZ/jzKMb5rxB"],[210],[2],211]],[0,"278g3bkEheMaX4KP4HMXC5",1,0],[1,3.1006205081939697,1.7383742332458496,-1.292324185371399]],[7,"Obj3d66-4399328-98-818",1,[[4,-407,[3,"f98VBqcLRUC6QX6pAospek"],[212],[2],213]],[0,"e5sGewlmdeZrNsPlg39uSe",1,0],[1,4.477558135986328,3.0502450466156006,-1.3723242282867432]],[7,"Obj3d66-4399328-100-687",1,[[4,-408,[3,"acn99axfdSqLzmnf+05/Zy"],[214],[2],215]],[0,"abE6h0EChcYLcLUxHG51qT",1,0],[1,3.1006205081939697,1.601354718208313,-1.3723242282867432]],[7,"Obj3d66-4399328-230-361",1,[[4,-409,[3,"2eb4P9rzdRVKXE6zvfcITX"],[216],[2],217]],[0,"dclsGdtI5dMICywIgEGidh",1,0],[1,14.325672149658203,1.600000262260437,5.45761251449585]],[6,"Obj3d66-4399328-230-362",1,[[4,-410,[3,"42BOKJ62BU9LMfjrx1Yi1L"],[218],[2],219]],[0,"43PCm6QQhefKAr93prEubx",1,0],[1,14.325672149658203,1.600000262260437,5.497613430023193],[3,3.621976833446891e-15,0.9999999999999958,-8.146034247147292e-8,4.3711388286737744e-8],[1,0.000009334667642611398,179.99999499104388,7.01669024749584e-15]],[6,"Obj3d66-4399328-204-476",1,[[13,[null],-411,[3,"b0NW6RLWRa0p3aTjGLoKYU"],[2],220]],[0,"0bRGXgWINWWJoUYVP5nd61",1,0],[1,11.900459289550781,1.4492539167404175,9.092669486999512],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[6,"Obj3d66-4399328-205-522",1,[[4,-412,[3,"e8tBGGTAtbeoBrdOoEuIeH"],[221],[2],222]],[0,"38owjzju1f5af1tmum9Ef8",1,0],[1,11.894553184509277,1.4273241758346558,9.197669982910156],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[6,"Obj3d66-4399328-208-634",1,[[4,-413,[3,"31TeqL1u9cDZ4F5UzQvo9l"],[223],[2],224]],[0,"c2hJL65RdfJrsmtthSUpny",1,0],[1,11.896646499633789,1.1989960670471191,9.082670211791992],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[6,"Obj3d66-4399328-211-467",1,[[13,[null],-414,[3,"b2Ao2e1w5fe64rH3QoSZ5O"],[2],225]],[0,"ec28yj+/xde6ccAdcsj2TI",1,0],[1,11.900459289550781,2.595121145248413,9.082670211791992],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[6,"Obj3d66-4399328-212-423",1,[[4,-415,[3,"4dXBeB+51faId9LMpqkV0Q"],[226],[2],227]],[0,"d52BW/xnxcQYZbbf+bpaoC",1,0],[1,11.658740043640137,1.4830234050750732,9.047670364379883],[3,1.7112913682821956e-15,0.9999999999999969,-2.1855694143368895e-8,7.549790126404308e-8],[1,0.0000025044780654876655,179.9999913485778,7.016708133325864e-15]],[6,"Box014",1,[[4,-416,[3,"65lnyPmZJeD6ylKxoMZlk+"],[228],[2],229]],[0,"19MfXFnJ9Ryr3TDkPdCjr8",1,0],[1,8.758172988891602,3.2202718257904053,7.677672386169434],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Box015",1,[[4,-417,[3,"be4a43PpJe7J9g7oRUgV5o"],[230],[2],231]],[0,"adCLejSuRWY5cFTALqW418",1,0],[1,-1.9499443769454956,3.201364040374756,1.5776699781417847],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Box016",1,[[4,-418,[3,"cfQ0YjV89ahpFEyE/UBiy6"],[232],[2],233]],[0,"69+gkrb4JbA70I0iaz/tt5",1,0],[1,5.15560245513916,3.201364040374756,-0.522330105304718],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Box017",1,[[4,-419,[3,"c2x7cPOsBR04EJNZ5gov2u"],[234],[2],235]],[0,"8eO3gJLtpaHrli+Klne7BU",1,0],[1,11.708727836608887,3.201354503631592,3.3778061866760254],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Obj3d66-4399328-140-588",1,[[4,-420,[3,"aff0cJgHNYvKMazcbyF6n7"],[236,237],[2],238]],[0,"28SlSrIwVY4pLqIph4JbGG",1,0],[1,8.870221138000488,0.800000011920929,5.142672538757324],[3,7.549790126404286e-8,-8.146034247147277e-8,0.9999999999999938,4.312495879740477e-15],[1,-1,-1,-1],[1,179.99999066533235,-179.9999913485778,-2.105721898611584e-13]],[10,"Obj3d66-4399328-142-487",1,[[4,-421,[3,"7fgfTX8MhcGYKthc5yw98L"],[239],[2],240]],[0,"e4C9RscoNZOa+/RlXvmEIN",1,0],[1,10.190220832824707,1.2808711528778076,5.142672538757324],[3,7.549790126404286e-8,-8.146034247147277e-8,0.9999999999999938,4.312495879740477e-15],[1,-1,-1,-1],[1,179.99999066533235,-179.9999913485778,-2.105721898611584e-13]],[10,"Obj3d66-4399328-143-226",1,[[4,-422,[3,"bcR7AkNUpfgZdZ+gpNEsGm"],[241],[2],242]],[0,"984CPTxi5fL5/CwekPvJdr",1,0],[1,9.670220375061035,1.2808711528778076,5.142672538757324],[3,7.549790126404286e-8,-8.146034247147277e-8,0.9999999999999938,4.312495879740477e-15],[1,-1,-1,-1],[1,179.99999066533235,-179.9999913485778,-2.105721898611584e-13]],[10,"Obj3d66-4399328-151-166",1,[[4,-423,[3,"8fXRRPTWBa44/Xp6dhh7Tx"],[243],[2],244]],[0,"b2n8UXg5dYJpo21WEsufdl",1,0],[1,9.15022087097168,1.2808711528778076,5.142672538757324],[3,7.549790126404286e-8,-8.146034247147277e-8,0.9999999999999938,4.312495879740477e-15],[1,-1,-1,-1],[1,179.99999066533235,-179.9999913485778,-2.105721898611584e-13]],[10,"Obj3d66-4399328-152-250",1,[[4,-424,[3,"5bZo+VvchakIJu+gWE+yec"],[245],[2],246]],[0,"efaM/3AMVeZYtMv+DlXafH",1,0],[1,8.630220413208008,1.600000023841858,5.137672424316406],[3,7.549790126404286e-8,-8.146034247147277e-8,0.9999999999999938,4.312495879740477e-15],[1,-1,-1,-1],[1,179.99999066533235,-179.9999913485778,-2.105721898611584e-13]],[10,"Obj3d66-4399328-1651-416",1,[[4,-425,[3,"42YNnPcKhZc6cKa0Yswy5o"],[247],[2],248]],[0,"4aZDT4Tetc1pF7R6upYTo4",1,0],[1,9.56307601928711,0.857895016670227,8.987455368041992],[3,4.316692927994067e-15,0.9999999999999809,-2.1855694143368548e-8,1.947071694985388e-7],[1,9.87101936340332,9.87101936340332,9.87101936340332],[1,0.0000025044780654876676,179.99997768820188,7.0167372537801025e-15]]],0,[0,3,1,0,0,1,0,-1,10,0,-2,11,0,-3,12,0,-4,13,0,-5,14,0,-6,15,0,-7,16,0,-8,2,0,-9,38,0,-10,5,0,-11,6,0,-12,7,0,-13,55,0,-14,56,0,-15,57,0,-16,58,0,-17,59,0,-18,60,0,-19,61,0,-20,62,0,-21,63,0,-22,64,0,-23,65,0,-24,66,0,-25,67,0,-26,68,0,-27,69,0,-28,70,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,-59,71,0,-60,72,0,-61,73,0,-62,74,0,-63,75,0,3,1,0,2,1,0,3,1,0,2,1,0,-66,76,0,3,1,0,2,1,0,-68,77,0,-69,78,0,-70,79,0,-71,80,0,-72,81,0,-73,82,0,-74,83,0,-75,84,0,-76,85,0,-77,86,0,-78,9,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,-85,90,0,-86,91,0,-87,92,0,-88,93,0,-89,94,0,-90,95,0,-91,96,0,-92,97,0,-93,98,0,-94,99,0,-95,100,0,-96,101,0,-97,102,0,-98,103,0,-99,104,0,-100,105,0,-101,106,0,-102,107,0,-103,108,0,3,1,0,2,1,0,-105,109,0,-106,110,0,-107,111,0,-108,112,0,-109,113,0,-110,114,0,-111,115,0,-112,116,0,3,1,0,2,1,0,3,1,0,2,1,0,-115,117,0,-116,118,0,-117,119,0,-118,120,0,-119,121,0,-120,122,0,-121,123,0,-122,124,0,-123,125,0,-124,126,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,3,1,0,2,1,0,-160,127,0,-161,128,0,-162,129,0,-163,130,0,-164,131,0,-165,132,0,-166,133,0,-167,134,0,-168,135,0,-169,136,0,-1,17,0,-2,18,0,-3,19,0,-4,20,0,-5,21,0,-6,22,0,-7,23,0,-8,24,0,-9,25,0,2,2,0,2,2,0,2,2,0,-13,3,0,-14,4,0,-1,26,0,-2,27,0,-3,28,0,-4,29,0,-5,30,0,-6,31,0,-1,32,0,-2,33,0,-3,34,0,-4,35,0,-5,36,0,-6,37,0,-1,39,0,-2,40,0,-3,41,0,-4,42,0,2,5,0,2,5,0,-1,43,0,-2,44,0,-3,45,0,-4,46,0,2,6,0,2,6,0,-1,47,0,-2,48,0,-3,49,0,-4,50,0,-5,8,0,-1,51,0,-2,52,0,-3,53,0,-4,54,0,-1,87,0,-2,88,0,-3,89,0,0,10,0,0,11,0,0,12,0,0,13,0,0,14,0,0,15,0,0,16,0,0,17,0,0,18,0,0,19,0,0,20,0,0,21,0,0,22,0,0,23,0,0,24,0,0,25,0,0,26,0,0,27,0,0,28,0,0,29,0,0,30,0,0,31,0,0,32,0,0,33,0,0,34,0,0,35,0,0,36,0,0,37,0,0,38,0,0,39,0,0,40,0,0,41,0,0,42,0,0,43,0,0,44,0,0,45,0,0,46,0,0,47,0,0,48,0,0,49,0,0,50,0,0,51,0,0,52,0,0,53,0,0,54,0,0,55,0,0,56,0,0,57,0,0,58,0,0,59,0,0,60,0,0,61,0,0,62,0,0,63,0,0,64,0,0,65,0,0,66,0,0,67,0,0,68,0,0,69,0,0,70,0,0,71,0,0,72,0,0,73,0,0,74,0,0,75,0,0,76,0,0,77,0,0,78,0,0,79,0,0,80,0,0,81,0,0,82,0,0,83,0,0,84,0,0,85,0,0,86,0,0,87,0,0,88,0,0,89,0,0,90,0,0,91,0,0,92,0,0,93,0,0,94,0,0,95,0,0,96,0,0,97,0,0,98,0,0,99,0,0,100,0,0,101,0,0,102,0,0,103,0,0,104,0,0,105,0,0,106,0,0,107,0,0,108,0,0,109,0,0,110,0,0,111,0,0,112,0,0,113,0,0,114,0,0,115,0,0,116,0,0,117,0,0,118,0,0,119,0,0,120,0,0,121,0,0,122,0,0,123,0,0,124,0,0,125,0,0,126,0,0,127,0,0,128,0,0,129,0,0,130,0,0,131,0,0,132,0,0,133,0,0,134,0,0,135,0,0,136,0,11,1,425],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-2,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,12],[35,36,1,37,9,38,1,39,40,41,7,42,1,43,6,44,45,46,6,47,6,48,7,49,50,51,2,52,1,53,54,2,55,2,56,2,57,2,58,2,59,2,60,1,61,1,62,1,63,1,64,1,65,1,66,67,68,1,69,70,71,6,72,3,73,74,75,6,76,1,77,1,78,79,80,3,81,82,83,84,85,4,86,6,87,3,88,4,89,90,91,10,92,4,93,4,94,4,95,4,96,97,98,99,100,101,102,5,103,5,104,5,105,5,106,5,107,5,108,5,109,110,111,112,113,114,115,116,117,118,119,120,3,121,122,123,3,124,3,125,3,126,3,127,3,128,3,129,13,130,131,132,6,133,13,134,1,135,1,136,137,138,139,140,4,141,142,143,144,145,146,147,1,148,9,149,150,151,152,153,2,154,7,155,2,156,2,157,158,159,2,160,161,162,163,164,14,165,166,167,2,168,169,170,7,171,2,172,3,173,174,175,3,176,14,177,10,178,10,179,180,181,182,183,184,185,4,186,187,188,189,190,191,192,193,194,5,195,196,8,197,8,198,8,199,8,200,4,201,15,15]],[[[1,".bin",1799068051,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.5,-0.9300000071525574,0],"maxPosition",8,[1,2.5,0.9300000071525574,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",2143741706,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.579380989074707,-1.5200005769729614,-0.019999999552965164],"maxPosition",8,[1,0.5793799757957458,1.5200005769729614,0.019999999552965164]]],-1],0,0,[],[],[]],[[[8,"zhaopianqiang",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[202,0]],[[[1,".bin",3139268622,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.149459958076477,-0.0024999999441206455,0],"maxPosition",8,[1,0.8305322527885437,0.0024999999441206455,3.200000047683716]]],-1],0,0,[],[],[]],[[[1,".bin",2807205022,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.302191734313965,-1.6006817817687988,-0.020000366494059563],"maxPosition",8,[1,2.4424996376037598,1.5918537378311157,0.02000003680586815]]],-1],0,0,[],[],[]],[[[1,".bin",289458100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3159853518009186,-0.800000011920929,1.525878978725359e-8],"maxPosition",8,[1,-0.10607968270778656,1.4382559061050415,0.010000023059546947]]],-1],0,0,[],[],[]],[[[1,".bin",3290550997,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-3.352203130722046,-1.4830214977264404,-0.0024999999441206455],"maxPosition",8,[1,3.144242286682129,1.493087887763977,0.0024999999441206455]]],-1],0,0,[],[],[]],[[[1,".bin",1011078414,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.8851816654205322,-0.3499999940395355,0],"maxPosition",8,[1,0.8851816654205322,-0.05485742166638374,0.06499999761581421]]],-1],0,0,[],[],[]],[[[1,".bin",2700095053,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.7778091430664062,-0.4353753924369812,0.23800000548362732],"maxPosition",8,[1,0.7778091430664062,0.4829593896865845,0.24199999868869781]]],-1],0,0,[],[],[]],[[[1,".bin",1541366648,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.1686045080423355,-0.26682141423225403,-0.07500000298023224],"maxPosition",8,[1,0.2825039029121399,0.26682141423225403,0.07500001043081284]]],-1],0,0,[],[],[]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-12-5274",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4538652002811432,"roughness":0.05677715316414833},"albedoScale",8,[1,0.8640222549438477,0.8640222549438477,0.8640222549438477]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",4007038963,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.8250000476837158,-1.600000023841858,-0.006045898422598839],"maxPosition",8,[1,2.2971677780151367,1.600000023841858,0.07206252217292786]]],-1],0,0,[],[],[]],[[[1,".bin",2814392591,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":768,"count":192,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":120,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.3102211356163025,-1.25,-0.1199999675154686],"maxPosition",8,[1,3.499488353729248,1.760378122329712,0.04000002518296242]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[203,0]],[[[1,".bin",4183865734,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.09984374791383743,-3.1500000953674316,0],"maxPosition",8,[1,0.09946875274181366,3.1500000953674316,3.200000047683716]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[16,0]],[[[8,"qianyan08TV",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[204,0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[205,0]],[[[1,".bin",2405167285,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.1686045229434967,-0.3534669578075409,-0.07500000298023224],"maxPosition",8,[1,0.2481086403131485,0.2668214440345764,0.07500004023313522]]],-1],0,0,[],[],[]],[[[8,"hongse",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0.6127451062202454,0.11846406012773514,0.11846406012773514]]],11]]],0,0,[0],[4],[0]],[[[8,"Mat3d66-4399328-15-9557",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"roughness":0.17407765984535217},"albedoScale",8,[1,1,1,1]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",2148211907,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":711792,"length":287064,"count":71766,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":711792,"count":29658,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.060879454016685486,-0.08695425093173981,0],"maxPosition",8,[1,0.16419939696788788,0.08695428818464279,0.0010000000474974513]]],-1],0,0,[],[],[]],[[[8,"baise",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.5052787661552429,"roughness":0.061035413295030594},"albedoScale",8,[1,0.8539584875106812,0.8539584875106812,0.8539584875106812]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",3003838369,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":96,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":96,"count":4,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.19999998807907104,-1.600000023841858,0],"maxPosition",8,[1,0.1837707906961441,1.600000023841858,0]]],-1],0,0,[],[],[]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",1080433312,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":624,"count":156,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":72,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-1.600000023841858,0],"maxPosition",8,[1,0.5,1.600000023841858,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",4081397114,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":24192,"length":5904,"count":1476,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":24192,"count":504,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.350000023841858,-1.350000023841858,0],"maxPosition",8,[1,1.350000023841858,1.350000023841858,0.08500000089406967]]],-1],0,0,[],[],[]],[[[1,".bin",3861515165,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.6806293725967407,-1.25,0],"maxPosition",8,[1,1.818994164466858,1.1239453554153442,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",2884360320,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.2261035442352295,-0.03000006079673767,0],"maxPosition",8,[1,2.2261035442352295,0.029999999329447746,3.201364040374756]]],-1],0,0,[],[],[]],[[[1,".bin",3231540652,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.6499999761581421,-0.375,0],"maxPosition",8,[1,0.6499999761581421,0.375,0.004999999888241291]]],-1],0,0,[],[],[]],[[[8,"biankuang",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.2705882489681244,0.2705882489681244,0.2705882489681244]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",3109519508,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.759952068328857,-9.097661018371582,0.0013544921530410647],"maxPosition",8,[1,-5.650110721588135,-5.077672004699707,3.2013540267944336]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-33-5727",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0.5759804248809814,0.5759804248809814,0.5759804248809814]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",1276618068,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4320,"length":1152,"count":288,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4320,"count":90,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.600000023841858,-1.600000023841858,0],"maxPosition",8,[1,1.600000023841858,1.600000023841858,0.004999999888241291]]],-1],0,0,[],[],[]],[[[1,".bin",1080433312,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":624,"count":156,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":72,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-1.600000023841858,0],"maxPosition",8,[1,0.5,1.600000023841858,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",3607360817,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":29616,"length":13104,"count":3276,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":29616,"count":1234,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.003386665368452668,-0.0027093354146927595,-2.960655332007178e-11],"maxPosition",8,[1,0.0033866730518639088,0.0027093314565718174,0.0009999999310821295]]],-1],0,0,[],[],[]],[[[1,".bin",3811327674,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":96,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":96,"count":4,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.20000000298023224,-1.600000023841858,0],"maxPosition",8,[1,0.20000000298023224,1.600000023841858,0]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[16,0]],[[[1,".bin",3299281399,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4320,"length":2064,"count":516,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4320,"count":180,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.17244134843349457,-0.27027246356010437,-0.06685788184404373],"maxPosition",8,[1,0.40223047137260437,0.2290642112493515,0.19692522287368774]]],-1],0,0,[],[],[]],[[[1,".bin",2612950430,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.75,-1.125,0],"maxPosition",8,[1,0.75,1.125,0.03999999910593033]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[206,0]],[[[1,".bin",2257396539,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35712,"length":35712,"count":8928,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35712,"count":1488,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.2040013074874878,-1.2040013074874878,-0.004000000189989805],"maxPosition",8,[1,1.2040013074874878,1.2040013074874878,0.004000000189989805]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[11,0]],[[[1,".bin",1868279629,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.149459958076477,-0.0024999999441206455,0],"maxPosition",8,[1,0.4305400252342224,0.0024999999441206455,3.200000047683716]]],-1],0,0,[],[],[]],[[[8,"muqiang",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[207,0]],[[[1,".bin",1737540684,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6449999809265137,-0.3700000047683716,0],"maxPosition",8,[1,0.6449999809265137,0.3700000047683716,0.004999999888241291]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-6-533",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.6116801500320435,"roughness":0.227980375289917},"albedoScale",8,[1,0.905351459980011,0.7807885408401489,0.7383239269256592]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",20568262,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.2310590744018555,-0.046327684074640274,0],"maxPosition",8,[1,1.9260936975479126,0.029999999329447746,2.8990767002105713]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[12,0]],[[[1,".bin",2077046388,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35712,"length":35712,"count":8928,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35712,"count":1488,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.3060020208358765,-1.3060020208358765,-0.006000000052154064],"maxPosition",8,[1,1.3060020208358765,1.3060020208358765,0.006000000052154064]]],-1],0,0,[],[],[]],[[[1,".bin",3535840382,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6449999809265137,-0.3700000047683716,0],"maxPosition",8,[1,0.6449999809265137,0.3700000047683716,0.004999999888241291]]],-1],0,0,[],[],[]],[[[1,".bin",3291992478,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-3.3569371700286865,-1.037500023841858,-7.629394893626795e-9],"maxPosition",8,[1,3.37695050239563,1.037500262260437,0.08999998867511749]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-10-8975",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184]]],11]]],0,0,[0],[4],[0]],[[[8,"Mat3d66-4399328-3-2689",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.9780260324478149,"roughness":0.06515481323003769},"albedoScale",8,[1,0.9337397813796997,0.9337397813796997,0.9337397813796997]]],11]]],0,0,[0],[4],[0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0},"albedoScale",8,[1,1,0.9803921580314636,0.9803921580314636]],{},{}],11,0,0]]],0,0,[0],[4],[0]],[[[1,".bin",395880185,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35712,"length":35712,"count":8928,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35712,"count":1488,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.3575025796890259,-1.3575025796890259,-0.007499999832361937],"maxPosition",8,[1,1.3575025796890259,1.3575025796890259,0.007499999832361937]]],-1],0,0,[],[],[]],[[[1,".bin",3547175540,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.6489999890327454,-0.37400001287460327,0.1550000011920929],"maxPosition",8,[1,0.6489999890327454,0.37400001287460327,0.1599999964237213]]],-1],0,0,[],[],[]],[[[1,".bin",60885679,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1440,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1440,"count":60,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-3.4000000953674316,-1.3975703716278076,-0.03999999910593033],"maxPosition",8,[1,0.43056079745292664,1.61766517162323,0.03999999910593033]]],-1],0,0,[],[],[]],[[[1,".bin",4212965591,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-1.0509361028671265,-1.0263140201568604,0],"maxPosition",8,[1,1.0509361028671265,1.1501213312149048,0.07000000029802322]]],-1],0,0,[],[],[]],[[[1,".bin",405309352,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.585110664367676,-9.03916072845459,0.0013541999505832791],"maxPosition",8,[1,-5.520110607147217,-5.639161109924316,2.796497106552124]]],-1],0,0,[],[],[]],[[[8,"zongse",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0.19607843458652496,0.1388888955116272,0.11846405267715454]]],11]]],0,0,[0],[4],[0]],[[[8,"fuzhoucheg",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[208,0]],[[[1,".bin",2037108498,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8640,"length":4224,"count":1056,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8640,"count":360,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.18239226937294006,-0.2827407121658325,-0.06734512001276016],"maxPosition",8,[1,0.41218143701553345,0.23903439939022064,0.20068861544132233]]],-1],0,0,[],[],[]],[[[1,".bin",408672838,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.7761845588684082,-0.125,-1.953560471534729],"maxPosition",8,[1,1.7761845588684082,-0.11538565903902054,0.9171203374862671]]],-1],0,0,[],[],[]],[[[1,".bin",3732538332,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.326936960220337,-0.009999999776482582,-0.003000000026077032],"maxPosition",8,[1,-0.5769296884536743,0.009999999776482582,0.003000000026077032]]],-1],0,0,[],[],[]],[[[1,".bin",2056264475,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4992,"length":1056,"count":264,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4992,"count":104,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.371156245470047,-0.12348828464746475,-0.004000000189989805],"maxPosition",8,[1,0.371156245470047,0.12349023669958115,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",780186280,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5.651110649108887,-9.097661972045898,6.000000212225132e-7],"maxPosition",8,[1,-1.6311209201812744,-9.02916145324707,3.2000010013580322]]],-1],0,0,[],[],[]],[[[1,".bin",676901475,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22656,"length":10032,"count":2508,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22656,"count":944,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.0030037497635930777,-0.00379747012630105,-0.005000011529773474],"maxPosition",8,[1,0.0030037423130124807,0.003797454759478569,-0.004000011365860701]]],-1],0,0,[],[],[]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",4013877106,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.004000000189989805,-1.600000023841858,-0.004000000189989805],"maxPosition",8,[1,0.004000000189989805,1.600000023841858,0.004000000189989805]]],-1],0,0,[],[],[]],[[[1,".bin",1569421751,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.17417652904987335,-0.3730866611003876,-0.07500005513429642],"maxPosition",8,[1,0.17868702113628387,0.5738582611083984,0.07500001788139343]]],-1],0,0,[],[],[]],[[[1,".bin",2504913137,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.14319726824760437,-0.800000011920929,0],"maxPosition",8,[1,0.06670861691236496,1.4382559061050415,0.010000007227063179]]],-1],0,0,[],[],[]],[[[1,".bin",252357265,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2231054306030273,-1.1501213312149048,0],"maxPosition",8,[1,1.2231054306030273,1.1501213312149048,0.07999999821186066]]],-1],0,0,[],[],[]],[[[1,".bin",541858265,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2880,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2880,"count":60,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.1898605227470398,-0.2482108473777771,-0.07500002533197403],"maxPosition",8,[1,0.22163833677768707,0.3581656813621521,0.07500000298023224]]],-1],0,0,[],[],[]],[[[1,".bin",93438787,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.7420658469200134,-0.3499999940395355,0],"maxPosition",8,[1,0.8851816654205322,-0.20242968201637268,0.06499999761581421]]],-1],0,0,[],[],[]],[[[1,".bin",4041328270,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4032,"length":1152,"count":288,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4032,"count":168,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.9659495949745178,-2.9078612327575684,-0.0030000002589076757],"maxPosition",8,[1,0.174010768532753,0.2921386659145355,0.0030000002589076757]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[209,0]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[1,".bin",2143741706,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.579380989074707,-1.5200005769729614,-0.019999999552965164],"maxPosition",8,[1,0.5793799757957458,1.5200005769729614,0.019999999552965164]]],-1],0,0,[],[],[]],[[[8,"guahua",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[210,0]],[[[1,".bin",3851379864,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":96,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":96,"count":4,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.2936965227127075,-1.600000023841858,0],"maxPosition",8,[1,0.09007421880960464,1.6000005006790161,0]]],-1],0,0,[],[],[]],[[[1,".bin",3206985732,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4320,"length":2064,"count":516,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4320,"count":180,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.17244134843349457,-0.270272433757782,-0.03386249020695686],"maxPosition",8,[1,0.40223047137260437,0.2290642112493515,0.01238187775015831]]],-1],0,0,[],[],[]],[[[1,".bin",3628608035,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":2688,"count":672,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":224,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.06573235243558884,-0.06573235243558884,0],"maxPosition",8,[1,0.06573235243558884,0.06573235243558884,0.009999999776482582]]],-1],0,0,[],[],[]],[[[8,"zhanqiang09",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[5,4],[211,0]],[[[1,".bin",777019432,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2304,"length":384,"count":96,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7950000166893005,-0.45500001311302185,0],"maxPosition",8,[1,0.7950000166893005,0.45500001311302185,0.004999999888241291]]],-1],0,0,[],[],[]],[[[1,".bin",2167718087,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":960,"length":120,"count":30,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":960,"count":20,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6000000238418579,-1.1881250143051147,0],"maxPosition",8,[1,0.6000000238418579,1.1881250143051147,0.004999999888241291]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{"cullMode":1},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0},"albedoScale",8,[1,0.5208333134651184,0.5208333134651184,0.5208333134651184]],{},{}],11,0,0]]],0,0,[0],[4],[0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[212,0]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[213,0]],[[[1,".bin",1399138142,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7749999761581421,-0.4350000023841858,0],"maxPosition",8,[1,0.7749999761581421,0.4350000023841858,0.004999999888241291]]],-1],0,0,[],[],[]],[[[9,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,4],[214,0]],[[[8,"Mat3d66-4399328-5-6003",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.9994226694107056,"roughness":0.06586829572916031},"albedoScale",8,[1,0.7978551983833313,0.7978551983833313,0.7978551983833313]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",1571261186,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.5,-1.0499999523162842,0],"maxPosition",8,[1,2.5,1.0499999523162842,0.07999999821186066]]],-1],0,0,[],[],[]],[[[1,".bin",4097582549,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-2.302191734313965,-1.6006817817687988,-0.020000437274575233],"maxPosition",8,[1,0.8778088092803955,1.5918537378311157,0.02000003680586815]]],-1],0,0,[],[],[]],[[[1,".bin",1786742570,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":48,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.9200000166893005,-1.064142107963562,0],"maxPosition",8,[1,0.9200000166893005,1.0499999523162842,0.029999999329447746]]],-1],0,0,[],[],[]],[[[1,".bin",774174264,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3456,"length":432,"count":108,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":6192,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3456,"count":72,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3888,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9279491901397705,-0.800000011920929,-3.984999418258667],"maxPosition",8,[1,6.2960662841796875,2.420271873474121,0.010000503621995449]]],-1],0,0,[],[],[]],[[[1,".bin",3192301017,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":345264,"length":68208,"count":17052,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":345264,"count":7193,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.484997034072876,-1.8601704835891724,-5.585137844085693],"maxPosition",8,[1,12.975004196166992,1.4013643264770508,13.972628593444824]]],-1],0,0,[],[],[]],[[[8,"Mat3d66-4399328-7-8192",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0},"albedoScale",8,[1,0,0,0],"emissiveScale",8,[2,1.5,1.5,1.5,1]]],11]]],0,0,[0],[4],[0]],[[[1,".bin",2185388401,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":576,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":576,"count":24,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-0.8200002312660217,-0.9700000286102295,0],"maxPosition",8,[1,0.8200002312660217,1.0499999523162842,0.20999999344348907]]],-1],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[3],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[48,[{}],[{}]]],0,0,[0],[4],[0]]]]
